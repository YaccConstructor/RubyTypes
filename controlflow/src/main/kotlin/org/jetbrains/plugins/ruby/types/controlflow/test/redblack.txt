{
  "nodes description": [
    {
      "element type": "String literal",
      "id": 1,
      "text": "'atomic'",
      "value": "atomic"
    },
    {
      "element type": "Call",
      "id": 2,
      "text": "require 'atomic'"
    },
    {
      "element type": "Constant",
      "id": 3,
      "text": "RedBlackTree"
    },
    {
      "element type": "Compound statement",
      "id": 4,
      "text": "require 'atomic'\n\nclass RedBlackTree\n  include Enumerable\n\n  class Node\n    UNDEFINED = Object.new\n\n    attr_reader :key, :value, :color\n    attr_reader :left, :right\n\n    def initialize(key, value, left, right, color = :RED)\n      @key = key\n      @value = value\n      @left = left\n      @right = right\n      # new node is added as RED\n      @color = color\n    end\n\n    def set_root\n      @color = :BLACK\n    end\n\n    def red?\n      @color == :RED\n    end\n\n    def black?\n      @color == :BLACK\n    end\n\n    def empty?\n      false\n    end\n\n    def size\n      @left.size + 1 + @right.size\n    end\n\n    # inorder\n    def each(&block)\n      @left.each(&block)\n      yield [@key, @value]\n      @right.each(&block)\n    end\n\n    def each_key\n      each do |k, v|\n        yield k\n      end\n    end\n\n    def each_value\n      each do |k, v|\n        yield v\n      end\n    end\n\n    def keys\n      collect { |k, v| k }\n    end\n\n    def values\n      collect { |k, v| v }\n    end\n\n    # returns new_root\n    def insert(key, value)\n      ret = self\n      case key <=> @key\n      when -1\n        @left = @left.insert(key, value)\n        if black? and @right.black? and @left.red? and !@left.children_color?(:BLACK)\n          ret = rebalance_for_left_insert\n        end\n      when 0\n        @value = value\n      when 1\n        @right = @right.insert(key, value)\n        if black? and @left.black? and @right.red? and !@right.children_color?(:BLACK)\n          ret = rebalance_for_right_insert\n        end\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      ret.pullup_red\n    end\n\n    # returns value\n    def retrieve(key)\n      case key <=> @key\n      when -1\n        @left.retrieve(key)\n      when 0\n        @value\n      when 1\n        @right.retrieve(key)\n      else\n        nil\n      end\n    end\n\n    # returns [deleted_node, new_root, is_rebalance_needed]\n    def delete(key)\n      ret = self\n      case key <=> @key\n      when -1\n        deleted, @left, rebalance = @left.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n      when 0\n        deleted = self\n        ret, rebalance = delete_node\n      when 1\n        deleted, @right, rebalance = @right.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_right_delete\n        end\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      [deleted, ret, rebalance]\n    end\n\n    def dump_tree(io, indent = '')\n      @right.dump_tree(io, indent + '  ')\n      io << indent << sprintf(\"#<%s:0x%010x %s %s> => %s\", self.class.name, __id__, @color, @key.inspect, @value.inspect) << $/\n      @left.dump_tree(io, indent + '  ')\n    end\n\n    def dump_sexp\n      left = @left.dump_sexp\n      right = @right.dump_sexp\n      if left or right\n        '(' + [@key, left || '-', right].compact.join(' ') + ')'\n      else\n        @key\n      end\n    end\n\n    # for debugging\n    def check_height\n      lh = @left.nil?  || @left.empty? ? 0 : @left.check_height\n      rh = @right.nil? || @right.empty? ? 0 : @right.check_height\n      if red?\n        if @left.red? or @right.red?\n          puts dump_tree(STDERR)\n          raise 'red/red assertion failed'\n        end\n      else\n        if lh != rh\n          puts dump_tree(STDERR)\n          raise \"black height unbalanced: #{lh} #{rh}\"\n        end\n      end\n      (lh > rh ? lh : rh) + (black? ? 1 : 0)\n    end\n\n    protected\n\n    def children_color?(color)\n      @right.color == @left.color && @right.color == color\n    end\n\n    def color=(color)\n      @color = color\n    end\n\n    def left=(left)\n      @left = left\n    end\n\n    def right=(right)\n      @right = right\n    end\n\n    def color_flip(other)\n      @color, other.color = other.color, @color\n    end\n\n    def delete_min\n      if @left.empty?\n        [self, *delete_node]\n      else\n        ret = self\n        deleted, @left, rebalance = @left.delete_min\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n        [deleted, ret, rebalance]\n      end\n    end\n\n    # trying to rebalance when the left sub-tree is 1 level lower than the right\n    def rebalance_for_left_delete\n      ret = self\n      rebalance = false\n      if black?\n        if @right.black?\n          if @right.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            @right.color = :RED\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            ret = balanced_rotate_left\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          ret = rotate_left\n          # try to rebalance in sub-tree\n          ret.left, rebalance = ret.left.rebalance_for_left_delete\n          raise 'should not happen' if rebalance\n        end\n      else # red\n        if @right.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          color_flip(@right)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          ret = balanced_rotate_left\n        end\n      end\n      [ret, rebalance]\n    end\n\n    # trying to rebalance when the right sub-tree is 1 level lower than the left\n    # See rebalance_for_left_delete.\n    def rebalance_for_right_delete\n      ret = self\n      rebalance = false\n      if black?\n        if @left.black?\n          if @left.children_color?(:BLACK)\n            @left.color = :RED\n            rebalance = true\n          else\n            ret = balanced_rotate_right\n          end\n        else\n          ret = rotate_right\n          ret.right, rebalance = ret.right.rebalance_for_right_delete\n          raise 'should not happen' if rebalance\n        end\n      else # red\n        if @left.children_color?(:BLACK)\n          color_flip(@left)\n        else\n          ret = balanced_rotate_right\n        end\n      end\n      [ret, rebalance]\n    end\n\n    # move 1 black from the right to the left by single/double rotation\n    def balanced_rotate_left\n      if @right.left.red? and @right.right.black?\n        @right = @right.rotate_right\n      end\n      ret = rotate_left\n      ret.right.color = ret.left.color = :BLACK\n      ret\n    end\n\n    # move 1 black from the left to the right by single/double rotation\n    def balanced_rotate_right\n      if @left.right.red? and @left.left.black?\n        @left = @left.rotate_left\n      end\n      ret = rotate_right\n      ret.right.color = ret.left.color = :BLACK\n      ret\n    end\n\n    # Right single rotation\n    # (b a (D c E)) where D and E are RED --> (d (B a c) E)\n    #\n    #   b              d\n    #  / \\            / \\\n    # a   D    ->    B   E\n    #    / \\        / \\\n    #   c   E      a   c\n    #\n    def rotate_left\n      root = @right\n      @right = root.left\n      root.left = self\n      root.color_flip(root.left)\n      root\n    end\n\n    # Left single rotation\n    # (d (B A c) e) where A and B are RED --> (b A (D c e))\n    #\n    #     d          b\n    #    / \\        / \\\n    #   B   e  ->  A   D\n    #  / \\            / \\\n    # A   c          c   e\n    #\n    def rotate_right\n      root = @left\n      @left = root.right\n      root.right = self\n      root.color_flip(root.right)\n      root\n    end\n\n    # Pull up red nodes\n    # (b (A C)) where A and C are RED --> (B (a c))\n    #\n    #   b          B\n    #  / \\   ->   / \\\n    # A   C      a   c\n    #\n    def pullup_red\n      if black? and children_color?(:RED)\n        @left.color = @right.color = :BLACK\n        self.color = :RED\n      end\n      self\n    end\n\n    private\n\n    # trying to rebalance when the left sub-tree is 1 level higher than the right\n    # precondition: self is black and @left is red\n    def rebalance_for_left_insert\n      # move 1 black from the left to the right by single/double rotation\n      if @left.right.red?\n        @left = @left.rotate_left\n      end\n      rotate_right\n    end\n\n    # trying to rebalance when the right sub-tree is 1 level higher than the left\n    # See rebalance_for_left_insert.\n    def rebalance_for_right_insert\n      if @right.left.red?\n        @right = @right.rotate_right\n      end\n      rotate_left\n    end\n\n    def delete_node\n      rebalance = false\n      if @left.empty? and @right.empty?\n        # just remove this node and ask rebalance to the parent\n        new_root = EMPTY\n        if black?\n          rebalance = true\n        end\n      elsif @left.empty? or @right.empty?\n        # pick the single children\n        new_root = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_root.red?\n          color_flip(new_root)\n        else\n          # just remove the red node\n        end\n      else\n        # pick the minimum node from the right sub-tree and replace self with it\n        deleted, @right, rebalance = @right.delete_min\n        new_root = Node.new(deleted.key, deleted.value, @left, @right, @color)\n        if rebalance\n          new_root, rebalance = new_root.rebalance_for_right_delete\n        end\n      end\n      [new_root, rebalance]\n    end\n\n    def collect\n      pool = []\n      each do |key, value|\n        pool << yield(key, value)\n      end\n      pool\n    end\n\n    class EmptyNode < Node\n      def initialize\n        @value = nil\n        @color = :BLACK\n      end\n\n      def empty?\n        true\n      end\n\n      def size\n        0\n      end\n\n      def each(&block)\n        # intentionally blank\n      end\n\n      # returns new_root\n      def insert(key, value)\n        Node.new(key, value, self, self)\n      end\n\n      # returns value\n      def retrieve(key)\n        UNDEFINED\n      end\n\n      # returns [deleted_node, new_root, is_rebalance_needed]\n      def delete(key)\n        [self, self, false]\n      end\n\n      def dump_tree(io, indent = '')\n        # intentionally blank\n      end\n\n      def dump_sexp\n        # intentionally blank\n      end\n    end\n    EMPTY = Node::EmptyNode.new.freeze\n  end\n\n  DEFAULT = Object.new\n\n  attr_accessor :default\n  attr_reader :default_proc\n\n  def initialize(default = DEFAULT, &block)\n    if block && default != DEFAULT\n      raise ArgumentError, 'wrong number of arguments'\n    end\n    @root = Node::EMPTY\n    @default = default\n    @default_proc = block\n  end\n\n  def root\n    @root\n  end\n\n  def empty?\n    root == Node::EMPTY\n  end\n\n  def size\n    root.size\n  end\n  alias length size\n\n  def each(&block)\n    if block_given?\n      root.each(&block)\n      self\n    else\n      Enumerator.new(root)\n    end\n  end\n  alias each_pair each\n\n  def each_key\n    if block_given?\n      root.each do |k, v|\n        yield k\n      end\n      self\n    else\n      Enumerator.new(root, :each_key)\n    end\n  end\n\n  def each_value\n    if block_given?\n      root.each do |k, v|\n        yield v\n      end\n      self\n    else\n      Enumerator.new(root, :each_value)\n    end\n  end\n\n  def keys\n    root.keys\n  end\n\n  def values\n    root.values\n  end\n\n  def clear\n    @root = Node::EMPTY\n  end\n\n  def []=(key, value)\n    @root = @root.insert(key, value)\n    @root.set_root\n    @root.check_height if $DEBUG\n  end\n  alias insert []=\n\n  def key?(key)\n    root.retrieve(key) != Node::UNDEFINED\n  end\n  alias has_key? key?\n\n  def [](key)\n    value = @root.retrieve(key)\n    if value == Node::UNDEFINED\n      default_value\n    else\n      value\n    end\n  end\n\n  def delete(key)\n    deleted, @root, rebalance = @root.delete(key)\n    unless empty?\n      @root.set_root\n      @root.check_height if $DEBUG\n    end\n    deleted.value\n  end\n\n  def dump_tree(io = '')\n    root.dump_tree(io)\n    io << $/\n    io\n  end\n\n  def dump_sexp\n    root.dump_sexp || ''\n  end\n\n  def to_hash\n    inject({}) { |r, (k, v)| r[k] = v; r }\n  end\n\n  private\n\n  def default_value\n    if @default != DEFAULT\n      @default\n    elsif @default_proc\n      @default_proc.call\n    else\n      nil\n    end\n  end\nend\n\nclass ConcurrentRedBlackTree < RedBlackTree\n  class ConcurrentNode < Node\n    # direction: ~LEFT == RIGHT, ~RIGHT == LEFT\n    LEFT = -1\n    RIGHT = 0\n\n    # @Overrides\n    def insert(key, value)\n      case key <=> @key\n      when -1\n        dir = LEFT\n      when 0\n        node = new_value(value)\n      when 1\n        dir = RIGHT\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      if dir\n        target = child(dir).insert(key, value)\n        node = new_child(dir, target)\n        if black? and child(~dir).black? and target.red? and !target.children_color?(:BLACK)\n          node = node.rebalance_for_insert(dir)\n        end\n      end\n      node.pullup_red\n    end\n\n    # @Overrides\n    def retrieve(key)\n      case key <=> @key\n      when -1\n        @left.retrieve(key)\n      when 0\n        @value\n      when 1\n        @right.retrieve(key)\n      else\n        nil\n      end\n    end\n\n    # @Overrides\n    def delete(key)\n      case key <=> @key\n      when -1\n        dir = LEFT\n      when 0\n        deleted = self\n        node, rebalance = delete_node\n      when 1\n        dir = RIGHT\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      if dir\n        deleted, target, rebalance = child(dir).delete(key)\n        node = new_child(dir, target)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(dir)\n        end\n      end\n      [deleted, node, rebalance]\n    end\n\n    protected\n\n    def new_children(dir, node, other, color = @color)\n      dir == LEFT ?\n          ConcurrentNode.new(@key, @value, node, other, color) :\n          ConcurrentNode.new(@key, @value, other, node, color)\n    end\n\n    def new_child(dir, node, color = @color)\n      dir == LEFT ?\n          ConcurrentNode.new(@key, @value, node, @right, color) :\n          ConcurrentNode.new(@key, @value, @left, node, color)\n    end\n\n    def new_color(color)\n      ConcurrentNode.new(@key, @value, @left, @right, color)\n    end\n\n    def new_value(value)\n      ConcurrentNode.new(@key, value, @left, @right, @color)\n    end\n\n    def child(dir)\n      dir == LEFT ? @left : @right\n    end\n\n    # @Overrides\n    def delete_min\n      if @left.empty?\n        [self, *delete_node]\n      else\n        deleted, left, rebalance = @left.delete_min\n        node = new_child(LEFT, left)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(LEFT)\n        end\n        [deleted, node, rebalance]\n      end\n    end\n\n    # rebalance when the left/right sub-tree is 1 level lower than the right/left\n    def rebalance_for_delete(dir)\n      target = child(~dir)\n      rebalance = false\n      if black?\n        if target.black?\n          if target.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            node = new_child(~dir, target.new_color(:RED))\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            node = balanced_rotate(dir)\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          node = rotate(dir)\n          # try to rebalance in sub-tree\n          target, rebalance = node.child(dir).rebalance_for_delete(dir)\n          raise 'should not happen' if rebalance\n          node = node.new_children(dir, target, node.child(~dir))\n        end\n      else # red\n        if target.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          node = new_child(~dir, target.new_color(@color), target.color)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          node = balanced_rotate(dir)\n        end\n      end\n      [node, rebalance]\n    end\n\n    # move 1 black from the right/left to the left/right by single/double rotation\n    def balanced_rotate(dir)\n      target = child(~dir)\n      if target.child(dir).red? and target.child(~dir).black?\n        node = new_child(~dir, target.rotate(~dir))\n      else\n        node = self\n      end\n      node = node.rotate(dir)\n      node.new_children(dir, node.child(dir).new_color(:BLACK), node.child(~dir).new_color(:BLACK))\n    end\n\n    # Right single rotation\n    # (b a (D c E)) where D and E are RED --> (d (B a c) E)\n    #\n    #   b              d\n    #  / \\            / \\\n    # a   D    ->    B   E\n    #    / \\        / \\\n    #   c   E      a   c\n    #\n    # Left single rotation\n    # (d (B A c) e) where A and B are RED --> (b A (D c e))\n    #\n    #     d          b\n    #    / \\        / \\\n    #   B   e  ->  A   D\n    #  / \\            / \\\n    # A   c          c   e\n    #\n    def rotate(dir)\n      new_root = child(~dir)\n      node = new_child(~dir, new_root.child(dir), new_root.color)\n      new_root.new_children(dir, node, new_root.child(~dir), @color)\n    end\n\n    # Pull up red nodes\n    # (b (A C)) where A and C are RED --> (B (a c))\n    #\n    #   b          B\n    #  / \\   ->   / \\\n    # A   C      a   c\n    #\n    # @Overrides\n    def pullup_red\n      if black? and @left.red? and @right.red?\n        new_children(LEFT, @left.new_color(:BLACK), @right.new_color(:BLACK), :RED)\n      else\n        self\n      end\n    end\n\n    # rebalance when the left/right sub-tree is 1 level higher than the right/left\n    # move 1 black from the left to the right by single/double rotation\n    #\n    # precondition: self is black and @left/@right is red\n    def rebalance_for_insert(dir)\n      node = self\n      if child(dir).child(~dir).red?\n        node = new_child(dir, child(dir).rotate(dir))\n      end\n      node.rotate(~dir)\n    end\n\n    private\n\n    # @Overrides\n    def delete_node\n      rebalance = false\n      if @left.empty? and @right.empty?\n        # just remove this node and ask rebalance to the parent\n        new_node = EMPTY_CONCURRENT\n        if black?\n          rebalance = true\n        end\n      elsif @left.empty? or @right.empty?\n        # pick the single children\n        new_node = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_node.red?\n          new_node = new_node.new_color(@color)\n        else\n          # just remove the red node\n        end\n      else\n        # pick the minimum node from the right sub-tree and replace self with it\n        deleted, right, rebalance = @right.delete_min\n        new_node = deleted.new_children(LEFT, @left, right, @color)\n        if rebalance\n          new_node, rebalance = new_node.rebalance_for_delete(RIGHT)\n        end\n      end\n      [new_node, rebalance]\n    end\n\n    class EmptyConcurrentNode < EmptyNode\n      # @Overrides\n      def insert(key, value)\n        ConcurrentNode.new(key, value, self, self)\n      end\n    end\n    EMPTY_CONCURRENT = ConcurrentNode::EmptyConcurrentNode.new.freeze\n  end\n\n  def initialize(default = DEFAULT, &block)\n    super\n    @root = Atomic.new(ConcurrentNode::EMPTY_CONCURRENT)\n  end\n\n  def root\n    @root.get\n  end\n\n  def empty?\n    root == ConcurrentNode::EMPTY_CONCURRENT\n  end\n\n  def clear\n    @root.set(ConcurrentNode::EMPTY_CONCURRENT)\n  end\n\n  def []=(key, value)\n    @root.update { |root|\n      root = root.insert(key, value)\n      root.set_root\n      root.check_height if $DEBUG\n      root\n    }\n  end\n  alias insert []=\n\n  def [](key)\n    value = @root.get.retrieve(key)\n    if value == Node::UNDEFINED\n      default_value\n    else\n      value\n    end\n  end\n\n  def delete(key)\n    deleted = nil\n    @root.update { |root|\n      deleted, root, rebalance = root.delete(key)\n      unless root == ConcurrentNode::EMPTY_CONCURRENT\n        root.set_root\n        root.check_height if $DEBUG\n      end\n      root\n    }\n    deleted.value\n  end\nend"
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "test2.rb"
}
{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "RedBlackTree"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "Enumerable"
    },
    {
      "element type": "Call",
      "id": 3,
      "text": "include Enumerable"
    },
    {
      "element type": "Constant",
      "id": 4,
      "text": "Object"
    },
    {
      "element type": "Reference",
      "id": 5,
      "text": "Object.new"
    },
    {
      "element type": "Constant",
      "id": 6,
      "text": "DEFAULT"
    },
    {
      "element type": "Assignment expression",
      "id": 7,
      "operation type": "="
    },
    {
      "element type": "Call",
      "id": 8,
      "text": "attr_accessor :default"
    },
    {
      "element type": "Call",
      "id": 9,
      "text": "attr_reader :default_proc"
    },
    {
      "element type": "Alias statement",
      "new name": "length",
      "old name": "size",
      "id": 10
    },
    {
      "element type": "Alias statement",
      "new name": "each_pair",
      "old name": "each",
      "id": 11
    },
    {
      "element type": "Alias statement",
      "new name": "insert",
      "old name": "[]=",
      "id": 12
    },
    {
      "element type": "Alias statement",
      "new name": "has_key?",
      "old name": "key?",
      "id": 13
    },
    {
      "element type": "Identifier private",
      "reference": "private",
      "kind": "unknown",
      "id": 14,
      "text": "private"
    },
    {
      "element type": "Compound statement",
      "id": 15,
      "text": "include Enumerable\n\n  class Node\n    UNDEFINED = Object.new\n\n    attr_reader :key, :value, :color\n    attr_reader :left, :right\n\n    def initialize(key, value, left, right, color = :RED)\n      @key = key\n      @value = value\n      @left = left\n      @right = right\n      # new node is added as RED\n      @color = color\n    end\n\n    def set_root\n      @color = :BLACK\n    end\n\n    def red?\n      @color == :RED\n    end\n\n    def black?\n      @color == :BLACK\n    end\n\n    def empty?\n      false\n    end\n\n    def size\n      @left.size + 1 + @right.size\n    end\n\n    # inorder\n    def each(&block)\n      @left.each(&block)\n      yield [@key, @value]\n      @right.each(&block)\n    end\n\n    def each_key\n      each do |k, v|\n        yield k\n      end\n    end\n\n    def each_value\n      each do |k, v|\n        yield v\n      end\n    end\n\n    def keys\n      collect { |k, v| k }\n    end\n\n    def values\n      collect { |k, v| v }\n    end\n\n    # returns new_root\n    def insert(key, value)\n      ret = self\n      case key <=> @key\n      when -1\n        @left = @left.insert(key, value)\n        if black? and @right.black? and @left.red? and !@left.children_color?(:BLACK)\n          ret = rebalance_for_left_insert\n        end\n      when 0\n        @value = value\n      when 1\n        @right = @right.insert(key, value)\n        if black? and @left.black? and @right.red? and !@right.children_color?(:BLACK)\n          ret = rebalance_for_right_insert\n        end\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      ret.pullup_red\n    end\n\n    # returns value\n    def retrieve(key)\n      case key <=> @key\n      when -1\n        @left.retrieve(key)\n      when 0\n        @value\n      when 1\n        @right.retrieve(key)\n      else\n        nil\n      end\n    end\n\n    # returns [deleted_node, new_root, is_rebalance_needed]\n    def delete(key)\n      ret = self\n      case key <=> @key\n      when -1\n        deleted, @left, rebalance = @left.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n      when 0\n        deleted = self\n        ret, rebalance = delete_node\n      when 1\n        deleted, @right, rebalance = @right.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_right_delete\n        end\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      [deleted, ret, rebalance]\n    end\n\n    def dump_tree(io, indent = '')\n      @right.dump_tree(io, indent + '  ')\n      io << indent << sprintf(\"#<%s:0x%010x %s %s> => %s\", self.class.name, __id__, @color, @key.inspect, @value.inspect) << $/\n      @left.dump_tree(io, indent + '  ')\n    end\n\n    def dump_sexp\n      left = @left.dump_sexp\n      right = @right.dump_sexp\n      if left or right\n        '(' + [@key, left || '-', right].compact.join(' ') + ')'\n      else\n        @key\n      end\n    end\n\n    # for debugging\n    def check_height\n      lh = @left.nil?  || @left.empty? ? 0 : @left.check_height\n      rh = @right.nil? || @right.empty? ? 0 : @right.check_height\n      if red?\n        if @left.red? or @right.red?\n          puts dump_tree(STDERR)\n          raise 'red/red assertion failed'\n        end\n      else\n        if lh != rh\n          puts dump_tree(STDERR)\n          raise \"black height unbalanced: #{lh} #{rh}\"\n        end\n      end\n      (lh > rh ? lh : rh) + (black? ? 1 : 0)\n    end\n\n    protected\n\n    def children_color?(color)\n      @right.color == @left.color && @right.color == color\n    end\n\n    def color=(color)\n      @color = color\n    end\n\n    def left=(left)\n      @left = left\n    end\n\n    def right=(right)\n      @right = right\n    end\n\n    def color_flip(other)\n      @color, other.color = other.color, @color\n    end\n\n    def delete_min\n      if @left.empty?\n        [self, *delete_node]\n      else\n        ret = self\n        deleted, @left, rebalance = @left.delete_min\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n        [deleted, ret, rebalance]\n      end\n    end\n\n    # trying to rebalance when the left sub-tree is 1 level lower than the right\n    def rebalance_for_left_delete\n      ret = self\n      rebalance = false\n      if black?\n        if @right.black?\n          if @right.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            @right.color = :RED\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            ret = balanced_rotate_left\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          ret = rotate_left\n          # try to rebalance in sub-tree\n          ret.left, rebalance = ret.left.rebalance_for_left_delete\n          raise 'should not happen' if rebalance\n        end\n      else # red\n        if @right.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          color_flip(@right)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          ret = balanced_rotate_left\n        end\n      end\n      [ret, rebalance]\n    end\n\n    # trying to rebalance when the right sub-tree is 1 level lower than the left\n    # See rebalance_for_left_delete.\n    def rebalance_for_right_delete\n      ret = self\n      rebalance = false\n      if black?\n        if @left.black?\n          if @left.children_color?(:BLACK)\n            @left.color = :RED\n            rebalance = true\n          else\n            ret = balanced_rotate_right\n          end\n        else\n          ret = rotate_right\n          ret.right, rebalance = ret.right.rebalance_for_right_delete\n          raise 'should not happen' if rebalance\n        end\n      else # red\n        if @left.children_color?(:BLACK)\n          color_flip(@left)\n        else\n          ret = balanced_rotate_right\n        end\n      end\n      [ret, rebalance]\n    end\n\n    # move 1 black from the right to the left by single/double rotation\n    def balanced_rotate_left\n      if @right.left.red? and @right.right.black?\n        @right = @right.rotate_right\n      end\n      ret = rotate_left\n      ret.right.color = ret.left.color = :BLACK\n      ret\n    end\n\n    # move 1 black from the left to the right by single/double rotation\n    def balanced_rotate_right\n      if @left.right.red? and @left.left.black?\n        @left = @left.rotate_left\n      end\n      ret = rotate_right\n      ret.right.color = ret.left.color = :BLACK\n      ret\n    end\n\n    # Right single rotation\n    # (b a (D c E)) where D and E are RED --> (d (B a c) E)\n    #\n    #   b              d\n    #  / \\            / \\\n    # a   D    ->    B   E\n    #    / \\        / \\\n    #   c   E      a   c\n    #\n    def rotate_left\n      root = @right\n      @right = root.left\n      root.left = self\n      root.color_flip(root.left)\n      root\n    end\n\n    # Left single rotation\n    # (d (B A c) e) where A and B are RED --> (b A (D c e))\n    #\n    #     d          b\n    #    / \\        / \\\n    #   B   e  ->  A   D\n    #  / \\            / \\\n    # A   c          c   e\n    #\n    def rotate_right\n      root = @left\n      @left = root.right\n      root.right = self\n      root.color_flip(root.right)\n      root\n    end\n\n    # Pull up red nodes\n    # (b (A C)) where A and C are RED --> (B (a c))\n    #\n    #   b          B\n    #  / \\   ->   / \\\n    # A   C      a   c\n    #\n    def pullup_red\n      if black? and children_color?(:RED)\n        @left.color = @right.color = :BLACK\n        self.color = :RED\n      end\n      self\n    end\n\n    private\n\n    # trying to rebalance when the left sub-tree is 1 level higher than the right\n    # precondition: self is black and @left is red\n    def rebalance_for_left_insert\n      # move 1 black from the left to the right by single/double rotation\n      if @left.right.red?\n        @left = @left.rotate_left\n      end\n      rotate_right\n    end\n\n    # trying to rebalance when the right sub-tree is 1 level higher than the left\n    # See rebalance_for_left_insert.\n    def rebalance_for_right_insert\n      if @right.left.red?\n        @right = @right.rotate_right\n      end\n      rotate_left\n    end\n\n    def delete_node\n      rebalance = false\n      if @left.empty? and @right.empty?\n        # just remove this node and ask rebalance to the parent\n        new_root = EMPTY\n        if black?\n          rebalance = true\n        end\n      elsif @left.empty? or @right.empty?\n        # pick the single children\n        new_root = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_root.red?\n          color_flip(new_root)\n        else\n          # just remove the red node\n        end\n      else\n        # pick the minimum node from the right sub-tree and replace self with it\n        deleted, @right, rebalance = @right.delete_min\n        new_root = Node.new(deleted.key, deleted.value, @left, @right, @color)\n        if rebalance\n          new_root, rebalance = new_root.rebalance_for_right_delete\n        end\n      end\n      [new_root, rebalance]\n    end\n\n    def collect\n      pool = []\n      each do |key, value|\n        pool << yield(key, value)\n      end\n      pool\n    end\n\n    class EmptyNode < Node\n      def initialize\n        @value = nil\n        @color = :BLACK\n      end\n\n      def empty?\n        true\n      end\n\n      def size\n        0\n      end\n\n      def each(&block)\n        # intentionally blank\n      end\n\n      # returns new_root\n      def insert(key, value)\n        Node.new(key, value, self, self)\n      end\n\n      # returns value\n      def retrieve(key)\n        UNDEFINED\n      end\n\n      # returns [deleted_node, new_root, is_rebalance_needed]\n      def delete(key)\n        [self, self, false]\n      end\n\n      def dump_tree(io, indent = '')\n        # intentionally blank\n      end\n\n      def dump_sexp\n        # intentionally blank\n      end\n    end\n    EMPTY = Node::EmptyNode.new.freeze\n  end\n\n  DEFAULT = Object.new\n\n  attr_accessor :default\n  attr_reader :default_proc\n\n  def initialize(default = DEFAULT, &block)\n    if block && default != DEFAULT\n      raise ArgumentError, 'wrong number of arguments'\n    end\n    @root = Node::EMPTY\n    @default = default\n    @default_proc = block\n  end\n\n  def root\n    @root\n  end\n\n  def empty?\n    root == Node::EMPTY\n  end\n\n  def size\n    root.size\n  end\n  alias length size\n\n  def each(&block)\n    if block_given?\n      root.each(&block)\n      self\n    else\n      Enumerator.new(root)\n    end\n  end\n  alias each_pair each\n\n  def each_key\n    if block_given?\n      root.each do |k, v|\n        yield k\n      end\n      self\n    else\n      Enumerator.new(root, :each_key)\n    end\n  end\n\n  def each_value\n    if block_given?\n      root.each do |k, v|\n        yield v\n      end\n      self\n    else\n      Enumerator.new(root, :each_value)\n    end\n  end\n\n  def keys\n    root.keys\n  end\n\n  def values\n    root.values\n  end\n\n  def clear\n    @root = Node::EMPTY\n  end\n\n  def []=(key, value)\n    @root = @root.insert(key, value)\n    @root.set_root\n    @root.check_height if $DEBUG\n  end\n  alias insert []=\n\n  def key?(key)\n    root.retrieve(key) != Node::UNDEFINED\n  end\n  alias has_key? key?\n\n  def [](key)\n    value = @root.retrieve(key)\n    if value == Node::UNDEFINED\n      default_value\n    else\n      value\n    end\n  end\n\n  def delete(key)\n    deleted, @root, rebalance = @root.delete(key)\n    unless empty?\n      @root.set_root\n      @root.check_height if $DEBUG\n    end\n    deleted.value\n  end\n\n  def dump_tree(io = '')\n    root.dump_tree(io)\n    io << $/\n    io\n  end\n\n  def dump_sexp\n    root.dump_sexp || ''\n  end\n\n  def to_hash\n    inject({}) { |r, (k, v)| r[k] = v; r }\n  end\n\n  private\n\n  def default_value\n    if @default != DEFAULT\n      @default\n    elsif @default_proc\n      @default_proc.call\n    else\n      nil\n    end\n  end"
    },
    {
      "element type": "Body statement",
      "id": 16
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": []
    }
  ],
  "holder": "RedBlackTree"
}

{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "Node"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "Object"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "Object.new"
    },
    {
      "element type": "Constant",
      "id": 4,
      "text": "UNDEFINED"
    },
    {
      "element type": "Assignment expression",
      "id": 5,
      "operation type": "="
    },
    {
      "element type": "Call",
      "id": 6,
      "text": "attr_reader :key, :value, :color"
    },
    {
      "element type": "Call",
      "id": 7,
      "text": "attr_reader :left, :right"
    },
    {
      "element type": "Identifier protected",
      "reference": "protected",
      "kind": "unknown",
      "id": 8,
      "text": "protected"
    },
    {
      "element type": "Identifier private",
      "reference": "private",
      "kind": "unknown",
      "id": 9,
      "text": "private"
    },
    {
      "element type": "Constant",
      "id": 10,
      "text": "Node"
    },
    {
      "element type": "Constant",
      "id": 11,
      "text": "Node"
    },
    {
      "element type": "Colon reference",
      "id": 12,
      "text": "Node::EmptyNode"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "Node::EmptyNode.new"
    },
    {
      "element type": "Reference",
      "id": 14,
      "text": "Node::EmptyNode.new.freeze"
    },
    {
      "element type": "Constant",
      "id": 15,
      "text": "EMPTY"
    },
    {
      "element type": "Assignment expression",
      "id": 16,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 17,
      "text": "UNDEFINED = Object.new\n\n    attr_reader :key, :value, :color\n    attr_reader :left, :right\n\n    def initialize(key, value, left, right, color = :RED)\n      @key = key\n      @value = value\n      @left = left\n      @right = right\n      # new node is added as RED\n      @color = color\n    end\n\n    def set_root\n      @color = :BLACK\n    end\n\n    def red?\n      @color == :RED\n    end\n\n    def black?\n      @color == :BLACK\n    end\n\n    def empty?\n      false\n    end\n\n    def size\n      @left.size + 1 + @right.size\n    end\n\n    # inorder\n    def each(&block)\n      @left.each(&block)\n      yield [@key, @value]\n      @right.each(&block)\n    end\n\n    def each_key\n      each do |k, v|\n        yield k\n      end\n    end\n\n    def each_value\n      each do |k, v|\n        yield v\n      end\n    end\n\n    def keys\n      collect { |k, v| k }\n    end\n\n    def values\n      collect { |k, v| v }\n    end\n\n    # returns new_root\n    def insert(key, value)\n      ret = self\n      case key <=> @key\n      when -1\n        @left = @left.insert(key, value)\n        if black? and @right.black? and @left.red? and !@left.children_color?(:BLACK)\n          ret = rebalance_for_left_insert\n        end\n      when 0\n        @value = value\n      when 1\n        @right = @right.insert(key, value)\n        if black? and @left.black? and @right.red? and !@right.children_color?(:BLACK)\n          ret = rebalance_for_right_insert\n        end\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      ret.pullup_red\n    end\n\n    # returns value\n    def retrieve(key)\n      case key <=> @key\n      when -1\n        @left.retrieve(key)\n      when 0\n        @value\n      when 1\n        @right.retrieve(key)\n      else\n        nil\n      end\n    end\n\n    # returns [deleted_node, new_root, is_rebalance_needed]\n    def delete(key)\n      ret = self\n      case key <=> @key\n      when -1\n        deleted, @left, rebalance = @left.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n      when 0\n        deleted = self\n        ret, rebalance = delete_node\n      when 1\n        deleted, @right, rebalance = @right.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_right_delete\n        end\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      [deleted, ret, rebalance]\n    end\n\n    def dump_tree(io, indent = '')\n      @right.dump_tree(io, indent + '  ')\n      io << indent << sprintf(\"#<%s:0x%010x %s %s> => %s\", self.class.name, __id__, @color, @key.inspect, @value.inspect) << $/\n      @left.dump_tree(io, indent + '  ')\n    end\n\n    def dump_sexp\n      left = @left.dump_sexp\n      right = @right.dump_sexp\n      if left or right\n        '(' + [@key, left || '-', right].compact.join(' ') + ')'\n      else\n        @key\n      end\n    end\n\n    # for debugging\n    def check_height\n      lh = @left.nil?  || @left.empty? ? 0 : @left.check_height\n      rh = @right.nil? || @right.empty? ? 0 : @right.check_height\n      if red?\n        if @left.red? or @right.red?\n          puts dump_tree(STDERR)\n          raise 'red/red assertion failed'\n        end\n      else\n        if lh != rh\n          puts dump_tree(STDERR)\n          raise \"black height unbalanced: #{lh} #{rh}\"\n        end\n      end\n      (lh > rh ? lh : rh) + (black? ? 1 : 0)\n    end\n\n    protected\n\n    def children_color?(color)\n      @right.color == @left.color && @right.color == color\n    end\n\n    def color=(color)\n      @color = color\n    end\n\n    def left=(left)\n      @left = left\n    end\n\n    def right=(right)\n      @right = right\n    end\n\n    def color_flip(other)\n      @color, other.color = other.color, @color\n    end\n\n    def delete_min\n      if @left.empty?\n        [self, *delete_node]\n      else\n        ret = self\n        deleted, @left, rebalance = @left.delete_min\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n        [deleted, ret, rebalance]\n      end\n    end\n\n    # trying to rebalance when the left sub-tree is 1 level lower than the right\n    def rebalance_for_left_delete\n      ret = self\n      rebalance = false\n      if black?\n        if @right.black?\n          if @right.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            @right.color = :RED\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            ret = balanced_rotate_left\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          ret = rotate_left\n          # try to rebalance in sub-tree\n          ret.left, rebalance = ret.left.rebalance_for_left_delete\n          raise 'should not happen' if rebalance\n        end\n      else # red\n        if @right.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          color_flip(@right)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          ret = balanced_rotate_left\n        end\n      end\n      [ret, rebalance]\n    end\n\n    # trying to rebalance when the right sub-tree is 1 level lower than the left\n    # See rebalance_for_left_delete.\n    def rebalance_for_right_delete\n      ret = self\n      rebalance = false\n      if black?\n        if @left.black?\n          if @left.children_color?(:BLACK)\n            @left.color = :RED\n            rebalance = true\n          else\n            ret = balanced_rotate_right\n          end\n        else\n          ret = rotate_right\n          ret.right, rebalance = ret.right.rebalance_for_right_delete\n          raise 'should not happen' if rebalance\n        end\n      else # red\n        if @left.children_color?(:BLACK)\n          color_flip(@left)\n        else\n          ret = balanced_rotate_right\n        end\n      end\n      [ret, rebalance]\n    end\n\n    # move 1 black from the right to the left by single/double rotation\n    def balanced_rotate_left\n      if @right.left.red? and @right.right.black?\n        @right = @right.rotate_right\n      end\n      ret = rotate_left\n      ret.right.color = ret.left.color = :BLACK\n      ret\n    end\n\n    # move 1 black from the left to the right by single/double rotation\n    def balanced_rotate_right\n      if @left.right.red? and @left.left.black?\n        @left = @left.rotate_left\n      end\n      ret = rotate_right\n      ret.right.color = ret.left.color = :BLACK\n      ret\n    end\n\n    # Right single rotation\n    # (b a (D c E)) where D and E are RED --> (d (B a c) E)\n    #\n    #   b              d\n    #  / \\            / \\\n    # a   D    ->    B   E\n    #    / \\        / \\\n    #   c   E      a   c\n    #\n    def rotate_left\n      root = @right\n      @right = root.left\n      root.left = self\n      root.color_flip(root.left)\n      root\n    end\n\n    # Left single rotation\n    # (d (B A c) e) where A and B are RED --> (b A (D c e))\n    #\n    #     d          b\n    #    / \\        / \\\n    #   B   e  ->  A   D\n    #  / \\            / \\\n    # A   c          c   e\n    #\n    def rotate_right\n      root = @left\n      @left = root.right\n      root.right = self\n      root.color_flip(root.right)\n      root\n    end\n\n    # Pull up red nodes\n    # (b (A C)) where A and C are RED --> (B (a c))\n    #\n    #   b          B\n    #  / \\   ->   / \\\n    # A   C      a   c\n    #\n    def pullup_red\n      if black? and children_color?(:RED)\n        @left.color = @right.color = :BLACK\n        self.color = :RED\n      end\n      self\n    end\n\n    private\n\n    # trying to rebalance when the left sub-tree is 1 level higher than the right\n    # precondition: self is black and @left is red\n    def rebalance_for_left_insert\n      # move 1 black from the left to the right by single/double rotation\n      if @left.right.red?\n        @left = @left.rotate_left\n      end\n      rotate_right\n    end\n\n    # trying to rebalance when the right sub-tree is 1 level higher than the left\n    # See rebalance_for_left_insert.\n    def rebalance_for_right_insert\n      if @right.left.red?\n        @right = @right.rotate_right\n      end\n      rotate_left\n    end\n\n    def delete_node\n      rebalance = false\n      if @left.empty? and @right.empty?\n        # just remove this node and ask rebalance to the parent\n        new_root = EMPTY\n        if black?\n          rebalance = true\n        end\n      elsif @left.empty? or @right.empty?\n        # pick the single children\n        new_root = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_root.red?\n          color_flip(new_root)\n        else\n          # just remove the red node\n        end\n      else\n        # pick the minimum node from the right sub-tree and replace self with it\n        deleted, @right, rebalance = @right.delete_min\n        new_root = Node.new(deleted.key, deleted.value, @left, @right, @color)\n        if rebalance\n          new_root, rebalance = new_root.rebalance_for_right_delete\n        end\n      end\n      [new_root, rebalance]\n    end\n\n    def collect\n      pool = []\n      each do |key, value|\n        pool << yield(key, value)\n      end\n      pool\n    end\n\n    class EmptyNode < Node\n      def initialize\n        @value = nil\n        @color = :BLACK\n      end\n\n      def empty?\n        true\n      end\n\n      def size\n        0\n      end\n\n      def each(&block)\n        # intentionally blank\n      end\n\n      # returns new_root\n      def insert(key, value)\n        Node.new(key, value, self, self)\n      end\n\n      # returns value\n      def retrieve(key)\n        UNDEFINED\n      end\n\n      # returns [deleted_node, new_root, is_rebalance_needed]\n      def delete(key)\n        [self, self, false]\n      end\n\n      def dump_tree(io, indent = '')\n        # intentionally blank\n      end\n\n      def dump_sexp\n        # intentionally blank\n      end\n    end\n    EMPTY = Node::EmptyNode.new.freeze"
    },
    {
      "element type": "Body statement",
      "id": 18
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": []
    }
  ],
  "holder": "Node"
}

{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "value"
    },
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "method parameter declaration",
      "id": 3,
      "text": "left"
    },
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "method parameter declaration",
      "id": 4,
      "text": "right"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "method parameter declaration",
      "id": 5,
      "text": "color"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 6,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@key"
    },
    {
      "element type": "Assignment expression",
      "id": 8,
      "operation type": "="
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 9,
      "text": "value"
    },
    {
      "element type": "Instance variable",
      "id": 10,
      "text": "@value"
    },
    {
      "element type": "Assignment expression",
      "id": 11,
      "operation type": "="
    },
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "local variable",
      "id": 12,
      "text": "left"
    },
    {
      "element type": "Instance variable",
      "id": 13,
      "text": "@left"
    },
    {
      "element type": "Assignment expression",
      "id": 14,
      "operation type": "="
    },
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "local variable",
      "id": 15,
      "text": "right"
    },
    {
      "element type": "Instance variable",
      "id": 16,
      "text": "@right"
    },
    {
      "element type": "Assignment expression",
      "id": 17,
      "operation type": "="
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "local variable",
      "id": 18,
      "text": "color"
    },
    {
      "element type": "Instance variable",
      "id": 19,
      "text": "@color"
    },
    {
      "element type": "Assignment expression",
      "id": 20,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 21,
      "text": "@key = key\n      @value = value\n      @left = left\n      @right = right\n      # new node is added as RED\n      @color = color"
    },
    {
      "element type": "Body statement",
      "id": 22
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": []
    }
  ],
  "holder": "initialize"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@color"
    },
    {
      "element type": "Assignment expression",
      "id": 2,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "@color = :BLACK"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "set_root"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@color"
    },
    {
      "element type": "Binary expression",
      "id": 2,
      "text": "@color == :RED",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "@color == :RED"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "red?"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@color"
    },
    {
      "element type": "Binary expression",
      "id": 2,
      "text": "@color == :BLACK",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "@color == :BLACK"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "black?"
}



{
  "nodes description": [
    {
      "element type": "Pseudo constant",
      "id": 1,
      "text": "false"
    },
    {
      "element type": "Compound statement",
      "id": 2,
      "text": "false"
    },
    {
      "element type": "Body statement",
      "id": 3
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": []
    }
  ],
  "holder": "empty?"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 2,
      "text": "@left.size"
    },
    {
      "element type": "Integer constant",
      "id": 3,
      "text": "1"
    },
    {
      "element type": "Binary expression",
      "id": 4,
      "text": "@left.size + 1",
      "expression type": "Integer",
      "operation type": "+"
    },
    {
      "element type": "Instance variable",
      "id": 5,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 6,
      "text": "@right.size"
    },
    {
      "element type": "Binary expression",
      "id": 7,
      "text": "@left.size + 1 + @right.size",
      "expression type": "Integer",
      "operation type": "+"
    },
    {
      "element type": "Compound statement",
      "id": 8,
      "text": "@left.size + 1 + @right.size"
    },
    {
      "element type": "Body statement",
      "id": 9
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": []
    }
  ],
  "holder": "size"
}



{
  "nodes description": [
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "block"
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@left.each"
    },
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "local variable",
      "id": 4,
      "text": "block"
    },
    {
      "element type": "Call",
      "id": 5,
      "text": "@left.each(&block)"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@key"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@value"
    },
    {
      "element type": "Array",
      "id": 8,
      "text": "[@key, @value]"
    },
    {
      "element type": "Yield statement",
      "id": 9
    },
    {
      "element type": "Instance variable",
      "id": 10,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 11,
      "text": "@right.each"
    },
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "local variable",
      "id": 12,
      "text": "block"
    },
    {
      "element type": "Call",
      "id": 13,
      "text": "@right.each(&block)"
    },
    {
      "element type": "Compound statement",
      "id": 14,
      "text": "@left.each(&block)\n      yield [@key, @value]\n      @right.each(&block)"
    },
    {
      "element type": "Body statement",
      "id": 15
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": []
    }
  ],
  "holder": "each"
}



{
  "nodes description": [
    {
      "element type": "Identifier each",
      "reference": "each",
      "kind": "unknown",
      "id": 1,
      "text": "each"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "block parameter declaration",
      "id": 2,
      "text": "k"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "block parameter declaration",
      "id": 3,
      "text": "v"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "local variable",
      "id": 4,
      "text": "k"
    },
    {
      "element type": "Yield statement",
      "id": 5
    },
    {
      "element type": "Compound statement",
      "id": 6,
      "text": "yield k"
    },
    {
      "element type": "Body statement",
      "id": 7
    },
    {
      "element type": "Code block",
      "id": 8
    },
    {
      "element type": "Block call",
      "id": 9
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "each do |k, v|\n        yield k\n      end"
    },
    {
      "element type": "Body statement",
      "id": 11
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [
        2,
        9
      ]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [
        9,
        2
      ]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": []
    }
  ],
  "holder": "each_key"
}



{
  "nodes description": [
    {
      "element type": "Identifier each",
      "reference": "each",
      "kind": "unknown",
      "id": 1,
      "text": "each"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "block parameter declaration",
      "id": 2,
      "text": "k"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "block parameter declaration",
      "id": 3,
      "text": "v"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "local variable",
      "id": 4,
      "text": "v"
    },
    {
      "element type": "Yield statement",
      "id": 5
    },
    {
      "element type": "Compound statement",
      "id": 6,
      "text": "yield v"
    },
    {
      "element type": "Body statement",
      "id": 7
    },
    {
      "element type": "Code block",
      "id": 8
    },
    {
      "element type": "Block call",
      "id": 9
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "each do |k, v|\n        yield v\n      end"
    },
    {
      "element type": "Body statement",
      "id": 11
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [
        2,
        9
      ]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [
        9,
        2
      ]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": []
    }
  ],
  "holder": "each_value"
}



{
  "nodes description": [
    {
      "element type": "Identifier collect",
      "reference": "collect",
      "kind": "unknown",
      "id": 1,
      "text": "collect"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "block parameter declaration",
      "id": 2,
      "text": "k"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "block parameter declaration",
      "id": 3,
      "text": "v"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "local variable",
      "id": 4,
      "text": "k"
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "k"
    },
    {
      "element type": "Code block",
      "id": 6
    },
    {
      "element type": "Block call",
      "id": 7
    },
    {
      "element type": "Compound statement",
      "id": 8,
      "text": "collect { |k, v| k }"
    },
    {
      "element type": "Body statement",
      "id": 9
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [
        2,
        7
      ]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [
        7,
        2
      ]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": []
    }
  ],
  "holder": "keys"
}



{
  "nodes description": [
    {
      "element type": "Identifier collect",
      "reference": "collect",
      "kind": "unknown",
      "id": 1,
      "text": "collect"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "block parameter declaration",
      "id": 2,
      "text": "k"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "block parameter declaration",
      "id": 3,
      "text": "v"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "local variable",
      "id": 4,
      "text": "v"
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "v"
    },
    {
      "element type": "Code block",
      "id": 6
    },
    {
      "element type": "Block call",
      "id": 7
    },
    {
      "element type": "Compound statement",
      "id": 8,
      "text": "collect { |k, v| v }"
    },
    {
      "element type": "Body statement",
      "id": 9
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [
        2,
        7
      ]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [
        7,
        2
      ]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": []
    }
  ],
  "holder": "values"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "value"
    },
    {
      "element type": "Pseudo constant",
      "id": 3,
      "text": "self"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 4,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 5,
      "operation type": "="
    },
    {
      "element type": "Case statement",
      "id": 6
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 7,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@key"
    },
    {
      "element type": "Binary expression",
      "id": 9,
      "text": "key <=> @key",
      "expression type": "TrueClass or FalseClass",
      "operation type": "<=>"
    },
    {
      "element type": "When case",
      "id": 10
    },
    {
      "element type": "Integer constant",
      "id": 11,
      "text": "-1"
    },
    {
      "element type": "Instance variable",
      "id": 12,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "@left.insert"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 14,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 15,
      "text": "value"
    },
    {
      "element type": "Call",
      "id": 16,
      "text": "@left.insert(key, value)"
    },
    {
      "element type": "Instance variable",
      "id": 17,
      "text": "@left"
    },
    {
      "element type": "Assignment expression",
      "id": 18,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 19
    },
    {
      "element type": "Fid",
      "id": 20,
      "text": "black?"
    },
    {
      "element type": "Instance variable",
      "id": 23,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 24,
      "text": "@right.black?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 25,
      "text": "black? and @right.black?"
    },
    {
      "element type": "Instance variable",
      "id": 28,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 29,
      "text": "@left.red?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 30,
      "text": "black? and @right.black? and @left.red?"
    },
    {
      "element type": "Instance variable",
      "id": 33,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 34,
      "text": "@left.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 35,
      "text": "@left.children_color?(:BLACK)"
    },
    {
      "element type": "Unary expression",
      "id": 36,
      "text": "!@left.children_color?(:BLACK)",
      "expression type": "TrueClass or FalseClass",
      "operation": "!"
    },
    {
      "element type": "Boolean binary expression",
      "id": 37,
      "text": "black? and @right.black? and @left.red? and !@left.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 38,
      "text": "ret = rebalance_for_left_insert"
    },
    {
      "element type": "Identifier rebalance_for_left_insert",
      "reference": "rebalance_for_left_insert",
      "kind": "unknown",
      "id": 39,
      "text": "rebalance_for_left_insert"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 40,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 41,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 42,
      "text": "@left = @left.insert(key, value)\n        if black? and @right.black? and @left.red? and !@left.children_color?(:BLACK)\n          ret = rebalance_for_left_insert\n        end"
    },
    {
      "element type": "When case",
      "id": 43
    },
    {
      "element type": "Integer constant",
      "id": 44,
      "text": "0"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 45,
      "text": "value"
    },
    {
      "element type": "Instance variable",
      "id": 46,
      "text": "@value"
    },
    {
      "element type": "Assignment expression",
      "id": 47,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 48,
      "text": "@value = value"
    },
    {
      "element type": "When case",
      "id": 49
    },
    {
      "element type": "Integer constant",
      "id": 50,
      "text": "1"
    },
    {
      "element type": "Instance variable",
      "id": 51,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 52,
      "text": "@right.insert"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 53,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 54,
      "text": "value"
    },
    {
      "element type": "Call",
      "id": 55,
      "text": "@right.insert(key, value)"
    },
    {
      "element type": "Instance variable",
      "id": 56,
      "text": "@right"
    },
    {
      "element type": "Assignment expression",
      "id": 57,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 58
    },
    {
      "element type": "Fid",
      "id": 59,
      "text": "black?"
    },
    {
      "element type": "Instance variable",
      "id": 62,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 63,
      "text": "@left.black?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 64,
      "text": "black? and @left.black?"
    },
    {
      "element type": "Instance variable",
      "id": 67,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 68,
      "text": "@right.red?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 69,
      "text": "black? and @left.black? and @right.red?"
    },
    {
      "element type": "Instance variable",
      "id": 72,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 73,
      "text": "@right.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 74,
      "text": "@right.children_color?(:BLACK)"
    },
    {
      "element type": "Unary expression",
      "id": 75,
      "text": "!@right.children_color?(:BLACK)",
      "expression type": "TrueClass or FalseClass",
      "operation": "!"
    },
    {
      "element type": "Boolean binary expression",
      "id": 76,
      "text": "black? and @left.black? and @right.red? and !@right.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 77,
      "text": "ret = rebalance_for_right_insert"
    },
    {
      "element type": "Identifier rebalance_for_right_insert",
      "reference": "rebalance_for_right_insert",
      "kind": "unknown",
      "id": 78,
      "text": "rebalance_for_right_insert"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 79,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 80,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 81,
      "text": "@right = @right.insert(key, value)\n        if black? and @left.black? and @right.red? and !@right.children_color?(:BLACK)\n          ret = rebalance_for_right_insert\n        end"
    },
    {
      "element type": "Else block",
      "id": 82
    },
    {
      "element type": "Constant",
      "id": 83,
      "text": "TypeError"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 84,
      "text": "key"
    },
    {
      "element type": "Compound statement",
      "id": 85,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 86,
      "text": "@key"
    },
    {
      "element type": "Compound statement",
      "id": 87,
      "text": "@key"
    },
    {
      "element type": "String literal",
      "id": 88,
      "text": "\"cannot compare #{key} and #{@key} with <=>\"",
      "value": "cannot compare #{key} and #{@key} with <=>"
    },
    {
      "element type": "Call",
      "id": 89,
      "text": "raise TypeError, \"cannot compare #{key} and #{@key} with <=>\""
    },
    {
      "element type": "Compound statement",
      "id": 90,
      "text": "raise TypeError, \"cannot compare #{key} and #{@key} with <=>\""
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 91,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 92,
      "text": "ret.pullup_red"
    },
    {
      "element type": "Compound statement",
      "id": 93,
      "text": "ret = self\n      case key <=> @key\n      when -1\n        @left = @left.insert(key, value)\n        if black? and @right.black? and @left.red? and !@left.children_color?(:BLACK)\n          ret = rebalance_for_left_insert\n        end\n      when 0\n        @value = value\n      when 1\n        @right = @right.insert(key, value)\n        if black? and @left.black? and @right.red? and !@right.children_color?(:BLACK)\n          ret = rebalance_for_right_insert\n        end\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      ret.pullup_red"
    },
    {
      "element type": "Body statement",
      "id": 94
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [
        10,
        43,
        49,
        82
      ]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [
        21,
        22
      ]
    },
    {
      "from": 21,
      "to": [23]
    },
    {
      "from": 22,
      "to": [42]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [
        26,
        27
      ]
    },
    {
      "from": 26,
      "to": [28]
    },
    {
      "from": 27,
      "to": [42]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [
        31,
        32
      ]
    },
    {
      "from": 31,
      "to": [33]
    },
    {
      "from": 32,
      "to": [42]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": [
        38,
        42
      ]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [91]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": [48]
    },
    {
      "from": 48,
      "to": [91]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [53]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [55]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [
        60,
        61
      ]
    },
    {
      "from": 60,
      "to": [62]
    },
    {
      "from": 61,
      "to": [81]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [
        65,
        66
      ]
    },
    {
      "from": 65,
      "to": [67]
    },
    {
      "from": 66,
      "to": [81]
    },
    {
      "from": 67,
      "to": [68]
    },
    {
      "from": 68,
      "to": [69]
    },
    {
      "from": 69,
      "to": [
        70,
        71
      ]
    },
    {
      "from": 70,
      "to": [72]
    },
    {
      "from": 71,
      "to": [81]
    },
    {
      "from": 72,
      "to": [73]
    },
    {
      "from": 73,
      "to": [74]
    },
    {
      "from": 74,
      "to": [75]
    },
    {
      "from": 75,
      "to": [76]
    },
    {
      "from": 76,
      "to": [
        77,
        81
      ]
    },
    {
      "from": 77,
      "to": [78]
    },
    {
      "from": 78,
      "to": [79]
    },
    {
      "from": 79,
      "to": [80]
    },
    {
      "from": 80,
      "to": [81]
    },
    {
      "from": 81,
      "to": [91]
    },
    {
      "from": 82,
      "to": [83]
    },
    {
      "from": 83,
      "to": [84]
    },
    {
      "from": 84,
      "to": [85]
    },
    {
      "from": 85,
      "to": [86]
    },
    {
      "from": 86,
      "to": [87]
    },
    {
      "from": 87,
      "to": [88]
    },
    {
      "from": 88,
      "to": [89]
    },
    {
      "from": 89,
      "to": []
    },
    {
      "from": 90,
      "to": [91]
    },
    {
      "from": 91,
      "to": [92]
    },
    {
      "from": 92,
      "to": [93]
    },
    {
      "from": 93,
      "to": [94]
    },
    {
      "from": 94,
      "to": [95]
    },
    {
      "from": 95,
      "to": []
    }
  ],
  "holder": "insert"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Case statement",
      "id": 2
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 3,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@key"
    },
    {
      "element type": "Binary expression",
      "id": 5,
      "text": "key <=> @key",
      "expression type": "TrueClass or FalseClass",
      "operation type": "<=>"
    },
    {
      "element type": "When case",
      "id": 6
    },
    {
      "element type": "Integer constant",
      "id": 7,
      "text": "-1"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 9,
      "text": "@left.retrieve"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 10,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 11,
      "text": "@left.retrieve(key)"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "@left.retrieve(key)"
    },
    {
      "element type": "When case",
      "id": 13
    },
    {
      "element type": "Integer constant",
      "id": 14,
      "text": "0"
    },
    {
      "element type": "Instance variable",
      "id": 15,
      "text": "@value"
    },
    {
      "element type": "Compound statement",
      "id": 16,
      "text": "@value"
    },
    {
      "element type": "When case",
      "id": 17
    },
    {
      "element type": "Integer constant",
      "id": 18,
      "text": "1"
    },
    {
      "element type": "Instance variable",
      "id": 19,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 20,
      "text": "@right.retrieve"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 21,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 22,
      "text": "@right.retrieve(key)"
    },
    {
      "element type": "Compound statement",
      "id": 23,
      "text": "@right.retrieve(key)"
    },
    {
      "element type": "Else block",
      "id": 24
    },
    {
      "element type": "Pseudo constant",
      "id": 25,
      "text": "nil"
    },
    {
      "element type": "Compound statement",
      "id": 26,
      "text": "nil"
    },
    {
      "element type": "Compound statement",
      "id": 27,
      "text": "case key <=> @key\n      when -1\n        @left.retrieve(key)\n      when 0\n        @value\n      when 1\n        @right.retrieve(key)\n      else\n        nil\n      end"
    },
    {
      "element type": "Body statement",
      "id": 28
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [
        6,
        13,
        17,
        24
      ]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [27]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [27]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [27]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": []
    }
  ],
  "holder": "retrieve"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Pseudo constant",
      "id": 2,
      "text": "self"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 3,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 4,
      "operation type": "="
    },
    {
      "element type": "Case statement",
      "id": 5
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 6,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@key"
    },
    {
      "element type": "Binary expression",
      "id": 8,
      "text": "key <=> @key",
      "expression type": "TrueClass or FalseClass",
      "operation type": "<=>"
    },
    {
      "element type": "When case",
      "id": 9
    },
    {
      "element type": "Integer constant",
      "id": 10,
      "text": "-1"
    },
    {
      "element type": "Assignment expression",
      "id": 11,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 12,
      "text": "deleted"
    },
    {
      "element type": "Instance variable",
      "id": 13,
      "text": "@left"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 14,
      "text": "rebalance"
    },
    {
      "element type": "Instance variable",
      "id": 15,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 16,
      "text": "@left.delete"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 17,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 18,
      "text": "@left.delete(key)"
    },
    {
      "element type": "If statement",
      "id": 19
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 20,
      "text": "rebalance"
    },
    {
      "element type": "Compound statement",
      "id": 21,
      "text": "ret, rebalance = rebalance_for_left_delete"
    },
    {
      "element type": "Assignment expression",
      "id": 22,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 23,
      "text": "ret"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 24,
      "text": "rebalance"
    },
    {
      "element type": "Identifier rebalance_for_left_delete",
      "reference": "rebalance_for_left_delete",
      "kind": "unknown",
      "id": 25,
      "text": "rebalance_for_left_delete"
    },
    {
      "element type": "Compound statement",
      "id": 26,
      "text": "deleted, @left, rebalance = @left.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end"
    },
    {
      "element type": "When case",
      "id": 27
    },
    {
      "element type": "Integer constant",
      "id": 28,
      "text": "0"
    },
    {
      "element type": "Pseudo constant",
      "id": 29,
      "text": "self"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 30,
      "text": "deleted"
    },
    {
      "element type": "Assignment expression",
      "id": 31,
      "operation type": "="
    },
    {
      "element type": "Assignment expression",
      "id": 32,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 33,
      "text": "ret"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 34,
      "text": "rebalance"
    },
    {
      "element type": "Identifier delete_node",
      "reference": "delete_node",
      "kind": "unknown",
      "id": 35,
      "text": "delete_node"
    },
    {
      "element type": "Compound statement",
      "id": 36,
      "text": "deleted = self\n        ret, rebalance = delete_node"
    },
    {
      "element type": "When case",
      "id": 37
    },
    {
      "element type": "Integer constant",
      "id": 38,
      "text": "1"
    },
    {
      "element type": "Assignment expression",
      "id": 39,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 40,
      "text": "deleted"
    },
    {
      "element type": "Instance variable",
      "id": 41,
      "text": "@right"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 42,
      "text": "rebalance"
    },
    {
      "element type": "Instance variable",
      "id": 43,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 44,
      "text": "@right.delete"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 45,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 46,
      "text": "@right.delete(key)"
    },
    {
      "element type": "If statement",
      "id": 47
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 48,
      "text": "rebalance"
    },
    {
      "element type": "Compound statement",
      "id": 49,
      "text": "ret, rebalance = rebalance_for_right_delete"
    },
    {
      "element type": "Assignment expression",
      "id": 50,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 51,
      "text": "ret"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 52,
      "text": "rebalance"
    },
    {
      "element type": "Identifier rebalance_for_right_delete",
      "reference": "rebalance_for_right_delete",
      "kind": "unknown",
      "id": 53,
      "text": "rebalance_for_right_delete"
    },
    {
      "element type": "Compound statement",
      "id": 54,
      "text": "deleted, @right, rebalance = @right.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_right_delete\n        end"
    },
    {
      "element type": "Else block",
      "id": 55
    },
    {
      "element type": "Constant",
      "id": 56,
      "text": "TypeError"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 57,
      "text": "key"
    },
    {
      "element type": "Compound statement",
      "id": 58,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 59,
      "text": "@key"
    },
    {
      "element type": "Compound statement",
      "id": 60,
      "text": "@key"
    },
    {
      "element type": "String literal",
      "id": 61,
      "text": "\"cannot compare #{key} and #{@key} with <=>\"",
      "value": "cannot compare #{key} and #{@key} with <=>"
    },
    {
      "element type": "Call",
      "id": 62,
      "text": "raise TypeError, \"cannot compare #{key} and #{@key} with <=>\""
    },
    {
      "element type": "Compound statement",
      "id": 63,
      "text": "raise TypeError, \"cannot compare #{key} and #{@key} with <=>\""
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 64,
      "text": "deleted"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 65,
      "text": "ret"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 66,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 67,
      "text": "[deleted, ret, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 68,
      "text": "ret = self\n      case key <=> @key\n      when -1\n        deleted, @left, rebalance = @left.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n      when 0\n        deleted = self\n        ret, rebalance = delete_node\n      when 1\n        deleted, @right, rebalance = @right.delete(key)\n        if rebalance\n          ret, rebalance = rebalance_for_right_delete\n        end\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      [deleted, ret, rebalance]"
    },
    {
      "element type": "Body statement",
      "id": 69
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [
        9,
        27,
        37,
        55
      ]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [
        21,
        26
      ]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [64]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [64]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [43]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": [48]
    },
    {
      "from": 48,
      "to": [
        49,
        54
      ]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [53]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [64]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": []
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [65]
    },
    {
      "from": 65,
      "to": [66]
    },
    {
      "from": 66,
      "to": [67]
    },
    {
      "from": 67,
      "to": [68]
    },
    {
      "from": 68,
      "to": [69]
    },
    {
      "from": 69,
      "to": [70]
    },
    {
      "from": 70,
      "to": []
    }
  ],
  "holder": "delete"
}



{
  "nodes description": [
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "io"
    },
    {
      "element type": "String literal",
      "id": 2,
      "text": "''",
      "value": ""
    },
    {
      "element type": "Identifier indent",
      "reference": "indent",
      "kind": "method parameter declaration",
      "id": 3,
      "text": "indent"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 5,
      "text": "@right.dump_tree"
    },
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "local variable",
      "id": 6,
      "text": "io"
    },
    {
      "element type": "Identifier indent",
      "reference": "indent",
      "kind": "local variable",
      "id": 7,
      "text": "indent"
    },
    {
      "element type": "String literal",
      "id": 8,
      "text": "'  '",
      "value": "  "
    },
    {
      "element type": "Binary expression",
      "id": 9,
      "text": "indent + '  '",
      "expression type": "Integer",
      "operation type": "+"
    },
    {
      "element type": "Call",
      "id": 10,
      "text": "@right.dump_tree(io, indent + '  ')"
    },
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "local variable",
      "id": 11,
      "text": "io"
    },
    {
      "element type": "Identifier indent",
      "reference": "indent",
      "kind": "local variable",
      "id": 12,
      "text": "indent"
    },
    {
      "element type": "Binary expression",
      "id": 13,
      "text": "io << indent",
      "expression type": "Integer",
      "operation type": "<<"
    },
    {
      "element type": "String literal",
      "id": 14,
      "text": "\"#<%s:0x%010x %s %s> => %s\"",
      "value": "#<%s:0x%010x %s %s> => %s"
    },
    {
      "element type": "Pseudo constant",
      "id": 15,
      "text": "self"
    },
    {
      "element type": "Reference",
      "id": 16,
      "text": "self.class"
    },
    {
      "element type": "Reference",
      "id": 17,
      "text": "self.class.name"
    },
    {
      "element type": "Identifier __id__",
      "reference": "__id__",
      "kind": "unknown",
      "id": 18,
      "text": "__id__"
    },
    {
      "element type": "Instance variable",
      "id": 19,
      "text": "@color"
    },
    {
      "element type": "Instance variable",
      "id": 20,
      "text": "@key"
    },
    {
      "element type": "Reference",
      "id": 21,
      "text": "@key.inspect"
    },
    {
      "element type": "Instance variable",
      "id": 22,
      "text": "@value"
    },
    {
      "element type": "Reference",
      "id": 23,
      "text": "@value.inspect"
    },
    {
      "element type": "Call",
      "id": 24,
      "text": "sprintf(\"#<%s:0x%010x %s %s> => %s\", self.class.name, __id__, @color, @key.inspect, @value.inspect)"
    },
    {
      "element type": "Binary expression",
      "id": 25,
      "text": "io << indent << sprintf(\"#<%s:0x%010x %s %s> => %s\", self.class.name, __id__, @color, @key.inspect, @value.inspect)",
      "expression type": "Integer",
      "operation type": "<<"
    },
    {
      "element type": "Global variable",
      "id": 26,
      "text": "$/",
      "variable type": "GLOBAL_VARIABLE"
    },
    {
      "element type": "Binary expression",
      "id": 27,
      "text": "io << indent << sprintf(\"#<%s:0x%010x %s %s> => %s\", self.class.name, __id__, @color, @key.inspect, @value.inspect) << $/",
      "expression type": "Integer",
      "operation type": "<<"
    },
    {
      "element type": "Instance variable",
      "id": 28,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 29,
      "text": "@left.dump_tree"
    },
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "local variable",
      "id": 30,
      "text": "io"
    },
    {
      "element type": "Identifier indent",
      "reference": "indent",
      "kind": "local variable",
      "id": 31,
      "text": "indent"
    },
    {
      "element type": "String literal",
      "id": 32,
      "text": "'  '",
      "value": "  "
    },
    {
      "element type": "Binary expression",
      "id": 33,
      "text": "indent + '  '",
      "expression type": "Integer",
      "operation type": "+"
    },
    {
      "element type": "Call",
      "id": 34,
      "text": "@left.dump_tree(io, indent + '  ')"
    },
    {
      "element type": "Compound statement",
      "id": 35,
      "text": "@right.dump_tree(io, indent + '  ')\n      io << indent << sprintf(\"#<%s:0x%010x %s %s> => %s\", self.class.name, __id__, @color, @key.inspect, @value.inspect) << $/\n      @left.dump_tree(io, indent + '  ')"
    },
    {
      "element type": "Body statement",
      "id": 36
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": []
    }
  ],
  "holder": "dump_tree"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 2,
      "text": "@left.dump_sexp"
    },
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "local variable",
      "id": 3,
      "text": "left"
    },
    {
      "element type": "Assignment expression",
      "id": 4,
      "operation type": "="
    },
    {
      "element type": "Instance variable",
      "id": 5,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 6,
      "text": "@right.dump_sexp"
    },
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "local variable",
      "id": 7,
      "text": "right"
    },
    {
      "element type": "Assignment expression",
      "id": 8,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 9
    },
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "local variable",
      "id": 10,
      "text": "left"
    },
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "local variable",
      "id": 13,
      "text": "right"
    },
    {
      "element type": "Boolean binary expression",
      "id": 14,
      "text": "left or right"
    },
    {
      "element type": "Compound statement",
      "id": 15,
      "text": "'(' + [@key, left || '-', right].compact.join(' ') + ')'"
    },
    {
      "element type": "String literal",
      "id": 16,
      "text": "'('",
      "value": "("
    },
    {
      "element type": "Instance variable",
      "id": 17,
      "text": "@key"
    },
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "local variable",
      "id": 18,
      "text": "left"
    },
    {
      "element type": "String literal",
      "id": 21,
      "text": "'-'",
      "value": "-"
    },
    {
      "element type": "Boolean binary expression",
      "id": 22,
      "text": "left || '-'"
    },
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "local variable",
      "id": 23,
      "text": "right"
    },
    {
      "element type": "Array",
      "id": 24,
      "text": "[@key, left || '-', right]"
    },
    {
      "element type": "Reference",
      "id": 25,
      "text": "[@key, left || '-', right].compact"
    },
    {
      "element type": "Reference",
      "id": 26,
      "text": "[@key, left || '-', right].compact.join"
    },
    {
      "element type": "String literal",
      "id": 27,
      "text": "' '",
      "value": " "
    },
    {
      "element type": "Call",
      "id": 28,
      "text": "[@key, left || '-', right].compact.join(' ')"
    },
    {
      "element type": "Binary expression",
      "id": 29,
      "text": "'(' + [@key, left || '-', right].compact.join(' ')",
      "expression type": "Integer",
      "operation type": "+"
    },
    {
      "element type": "String literal",
      "id": 30,
      "text": "')'",
      "value": ")"
    },
    {
      "element type": "Binary expression",
      "id": 31,
      "text": "'(' + [@key, left || '-', right].compact.join(' ') + ')'",
      "expression type": "Integer",
      "operation type": "+"
    },
    {
      "element type": "Else block",
      "id": 32
    },
    {
      "element type": "Instance variable",
      "id": 33,
      "text": "@key"
    },
    {
      "element type": "Compound statement",
      "id": 34,
      "text": "@key"
    },
    {
      "element type": "Compound statement",
      "id": 35,
      "text": "left = @left.dump_sexp\n      right = @right.dump_sexp\n      if left or right\n        '(' + [@key, left || '-', right].compact.join(' ') + ')'\n      else\n        @key\n      end"
    },
    {
      "element type": "Body statement",
      "id": 36
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [
        11,
        12
      ]
    },
    {
      "from": 11,
      "to": [15]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [
        15,
        32
      ]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [
        19,
        20
      ]
    },
    {
      "from": 19,
      "to": [23]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [35]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": []
    }
  ],
  "holder": "dump_sexp"
}



{
  "nodes description": [
    {
      "element type": "Ternary expression",
      "id": 1
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@left.nil?"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 7,
      "text": "@left.empty?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 8,
      "text": "@left.nil?  || @left.empty?"
    },
    {
      "element type": "Integer constant",
      "id": 9,
      "text": "0"
    },
    {
      "element type": "Integer constant",
      "id": 10,
      "text": "0"
    },
    {
      "element type": "Reference",
      "id": 11,
      "text": "@left.check_height"
    },
    {
      "element type": "Instance variable",
      "id": 12,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "@left.check_height"
    },
    {
      "element type": "Identifier lh",
      "reference": "lh",
      "kind": "local variable",
      "id": 14,
      "text": "lh"
    },
    {
      "element type": "Assignment expression",
      "id": 15,
      "operation type": "="
    },
    {
      "element type": "Ternary expression",
      "id": 16
    },
    {
      "element type": "Instance variable",
      "id": 17,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 18,
      "text": "@right.nil?"
    },
    {
      "element type": "Instance variable",
      "id": 21,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 22,
      "text": "@right.empty?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 23,
      "text": "@right.nil? || @right.empty?"
    },
    {
      "element type": "Integer constant",
      "id": 24,
      "text": "0"
    },
    {
      "element type": "Integer constant",
      "id": 25,
      "text": "0"
    },
    {
      "element type": "Reference",
      "id": 26,
      "text": "@right.check_height"
    },
    {
      "element type": "Instance variable",
      "id": 27,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 28,
      "text": "@right.check_height"
    },
    {
      "element type": "Identifier rh",
      "reference": "rh",
      "kind": "local variable",
      "id": 29,
      "text": "rh"
    },
    {
      "element type": "Assignment expression",
      "id": 30,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 31
    },
    {
      "element type": "Fid",
      "id": 32,
      "text": "red?"
    },
    {
      "element type": "Compound statement",
      "id": 33,
      "text": "if @left.red? or @right.red?\n          puts dump_tree(STDERR)\n          raise 'red/red assertion failed'\n        end"
    },
    {
      "element type": "If statement",
      "id": 34
    },
    {
      "element type": "Instance variable",
      "id": 35,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 36,
      "text": "@left.red?"
    },
    {
      "element type": "Instance variable",
      "id": 39,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 40,
      "text": "@right.red?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 41,
      "text": "@left.red? or @right.red?"
    },
    {
      "element type": "Compound statement",
      "id": 42,
      "text": "puts dump_tree(STDERR)\n          raise 'red/red assertion failed'"
    },
    {
      "element type": "Constant",
      "id": 43,
      "text": "STDERR"
    },
    {
      "element type": "Call",
      "callee": "dump_tree",
      "id": 44,
      "text": "dump_tree(STDERR)"
    },
    {
      "element type": "Call",
      "id": 45,
      "text": "puts dump_tree(STDERR)"
    },
    {
      "element type": "String literal",
      "id": 46,
      "text": "'red/red assertion failed'",
      "value": "red/red assertion failed"
    },
    {
      "element type": "Call",
      "id": 47,
      "text": "raise 'red/red assertion failed'"
    },
    {
      "element type": "Else block",
      "id": 48
    },
    {
      "element type": "If statement",
      "id": 49
    },
    {
      "element type": "Identifier lh",
      "reference": "lh",
      "kind": "local variable",
      "id": 50,
      "text": "lh"
    },
    {
      "element type": "Identifier rh",
      "reference": "rh",
      "kind": "local variable",
      "id": 51,
      "text": "rh"
    },
    {
      "element type": "Binary expression",
      "id": 52,
      "text": "lh != rh",
      "expression type": "TrueClass or FalseClass",
      "operation type": "!="
    },
    {
      "element type": "Compound statement",
      "id": 53,
      "text": "puts dump_tree(STDERR)\n          raise \"black height unbalanced: #{lh} #{rh}\""
    },
    {
      "element type": "Constant",
      "id": 54,
      "text": "STDERR"
    },
    {
      "element type": "Call",
      "callee": "dump_tree",
      "id": 55,
      "text": "dump_tree(STDERR)"
    },
    {
      "element type": "Call",
      "id": 56,
      "text": "puts dump_tree(STDERR)"
    },
    {
      "element type": "Identifier lh",
      "reference": "lh",
      "kind": "local variable",
      "id": 57,
      "text": "lh"
    },
    {
      "element type": "Compound statement",
      "id": 58,
      "text": "lh"
    },
    {
      "element type": "Identifier rh",
      "reference": "rh",
      "kind": "local variable",
      "id": 59,
      "text": "rh"
    },
    {
      "element type": "Compound statement",
      "id": 60,
      "text": "rh"
    },
    {
      "element type": "String literal",
      "id": 61,
      "text": "\"black height unbalanced: #{lh} #{rh}\"",
      "value": "black height unbalanced: #{lh} #{rh}"
    },
    {
      "element type": "Call",
      "id": 62,
      "text": "raise \"black height unbalanced: #{lh} #{rh}\""
    },
    {
      "element type": "Compound statement",
      "id": 63,
      "text": "if lh != rh\n          puts dump_tree(STDERR)\n          raise \"black height unbalanced: #{lh} #{rh}\"\n        end"
    },
    {
      "element type": "Ternary expression",
      "id": 64
    },
    {
      "element type": "Identifier lh",
      "reference": "lh",
      "kind": "local variable",
      "id": 65,
      "text": "lh"
    },
    {
      "element type": "Identifier rh",
      "reference": "rh",
      "kind": "local variable",
      "id": 66,
      "text": "rh"
    },
    {
      "element type": "Binary expression",
      "id": 67,
      "text": "lh > rh",
      "expression type": "TrueClass or FalseClass",
      "operation type": ">"
    },
    {
      "element type": "Identifier lh",
      "reference": "lh",
      "kind": "local variable",
      "id": 68,
      "text": "lh"
    },
    {
      "element type": "Identifier lh",
      "reference": "lh",
      "kind": "local variable",
      "id": 69,
      "text": "lh"
    },
    {
      "element type": "Identifier rh",
      "reference": "rh",
      "kind": "local variable",
      "id": 70,
      "text": "rh"
    },
    {
      "element type": "Identifier rh",
      "reference": "rh",
      "kind": "local variable",
      "id": 71,
      "text": "rh"
    },
    {
      "element type": "Compound statement",
      "id": 72,
      "text": "lh > rh ? lh : rh"
    },
    {
      "element type": "Grouped expression",
      "id": 73
    },
    {
      "element type": "Ternary expression",
      "id": 74
    },
    {
      "element type": "Fid",
      "id": 75,
      "text": "black?"
    },
    {
      "element type": "Integer constant",
      "id": 76,
      "text": "1"
    },
    {
      "element type": "Integer constant",
      "id": 77,
      "text": "1"
    },
    {
      "element type": "Integer constant",
      "id": 78,
      "text": "0"
    },
    {
      "element type": "Integer constant",
      "id": 79,
      "text": "0"
    },
    {
      "element type": "Compound statement",
      "id": 80,
      "text": "black? ? 1 : 0"
    },
    {
      "element type": "Grouped expression",
      "id": 81
    },
    {
      "element type": "Binary expression",
      "id": 82,
      "text": "(lh > rh ? lh : rh) + (black? ? 1 : 0)",
      "expression type": "Integer",
      "operation type": "+"
    },
    {
      "element type": "Compound statement",
      "id": 83,
      "text": "lh = @left.nil?  || @left.empty? ? 0 : @left.check_height\n      rh = @right.nil? || @right.empty? ? 0 : @right.check_height\n      if red?\n        if @left.red? or @right.red?\n          puts dump_tree(STDERR)\n          raise 'red/red assertion failed'\n        end\n      else\n        if lh != rh\n          puts dump_tree(STDERR)\n          raise \"black height unbalanced: #{lh} #{rh}\"\n        end\n      end\n      (lh > rh ? lh : rh) + (black? ? 1 : 0)"
    },
    {
      "element type": "Body statement",
      "id": 84
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [
        4,
        5
      ]
    },
    {
      "from": 4,
      "to": [9]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [
        9,
        11
      ]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [14]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [
        19,
        20
      ]
    },
    {
      "from": 19,
      "to": [24]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [
        24,
        26
      ]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [29]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [
        33,
        48
      ]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [
        37,
        38
      ]
    },
    {
      "from": 37,
      "to": [42]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [
        42,
        64
      ]
    },
    {
      "from": 42,
      "to": [43]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": []
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [
        53,
        63
      ]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [55]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": []
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [65]
    },
    {
      "from": 65,
      "to": [66]
    },
    {
      "from": 66,
      "to": [67]
    },
    {
      "from": 67,
      "to": [
        68,
        70
      ]
    },
    {
      "from": 68,
      "to": [69]
    },
    {
      "from": 69,
      "to": [72]
    },
    {
      "from": 70,
      "to": [71]
    },
    {
      "from": 71,
      "to": [72]
    },
    {
      "from": 72,
      "to": [73]
    },
    {
      "from": 73,
      "to": [74]
    },
    {
      "from": 74,
      "to": [75]
    },
    {
      "from": 75,
      "to": [
        76,
        78
      ]
    },
    {
      "from": 76,
      "to": [77]
    },
    {
      "from": 77,
      "to": [80]
    },
    {
      "from": 78,
      "to": [79]
    },
    {
      "from": 79,
      "to": [80]
    },
    {
      "from": 80,
      "to": [81]
    },
    {
      "from": 81,
      "to": [82]
    },
    {
      "from": 82,
      "to": [83]
    },
    {
      "from": 83,
      "to": [84]
    },
    {
      "from": 84,
      "to": [85]
    },
    {
      "from": 85,
      "to": []
    }
  ],
  "holder": "check_height"
}



{
  "nodes description": [
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "color"
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@right.color"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 5,
      "text": "@left.color"
    },
    {
      "element type": "Binary expression",
      "id": 6,
      "text": "@right.color == @left.color",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Instance variable",
      "id": 9,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 10,
      "text": "@right.color"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "local variable",
      "id": 11,
      "text": "color"
    },
    {
      "element type": "Binary expression",
      "id": 12,
      "text": "@right.color == color",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Boolean binary expression",
      "id": 13,
      "text": "@right.color == @left.color && @right.color == color"
    },
    {
      "element type": "Compound statement",
      "id": 14,
      "text": "@right.color == @left.color && @right.color == color"
    },
    {
      "element type": "Body statement",
      "id": 15
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [
        7,
        8
      ]
    },
    {
      "from": 7,
      "to": [9]
    },
    {
      "from": 8,
      "to": [14]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": []
    }
  ],
  "holder": "children_color?"
}



{
  "nodes description": [
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "color"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "local variable",
      "id": 2,
      "text": "color"
    },
    {
      "element type": "Instance variable",
      "id": 3,
      "text": "@color"
    },
    {
      "element type": "Assignment expression",
      "id": 4,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "@color = color"
    },
    {
      "element type": "Body statement",
      "id": 6
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": []
    }
  ],
  "holder": "color="
}



{
  "nodes description": [
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "left"
    },
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "local variable",
      "id": 2,
      "text": "left"
    },
    {
      "element type": "Instance variable",
      "id": 3,
      "text": "@left"
    },
    {
      "element type": "Assignment expression",
      "id": 4,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "@left = left"
    },
    {
      "element type": "Body statement",
      "id": 6
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": []
    }
  ],
  "holder": "left="
}



{
  "nodes description": [
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "right"
    },
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "local variable",
      "id": 2,
      "text": "right"
    },
    {
      "element type": "Instance variable",
      "id": 3,
      "text": "@right"
    },
    {
      "element type": "Assignment expression",
      "id": 4,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "@right = right"
    },
    {
      "element type": "Body statement",
      "id": 6
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": []
    }
  ],
  "holder": "right="
}



{
  "nodes description": [
    {
      "element type": "Identifier other",
      "reference": "other",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "other"
    },
    {
      "element type": "Assignment expression",
      "id": 2,
      "operation type": "="
    },
    {
      "element type": "Instance variable",
      "id": 3,
      "text": "@color"
    },
    {
      "element type": "Identifier other",
      "reference": "other",
      "kind": "local variable",
      "id": 4,
      "text": "other"
    },
    {
      "element type": "Reference",
      "id": 5,
      "text": "other.color"
    },
    {
      "element type": "Identifier other",
      "reference": "other",
      "kind": "local variable",
      "id": 6,
      "text": "other"
    },
    {
      "element type": "Reference",
      "id": 7,
      "text": "other.color"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@color"
    },
    {
      "element type": "Compound statement",
      "id": 9,
      "text": "@color, other.color = other.color, @color"
    },
    {
      "element type": "Body statement",
      "id": 10
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": []
    }
  ],
  "holder": "color_flip"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@left.empty?"
    },
    {
      "element type": "Compound statement",
      "id": 4,
      "text": "[self, *delete_node]"
    },
    {
      "element type": "Pseudo constant",
      "id": 5,
      "text": "self"
    },
    {
      "element type": "Identifier delete_node",
      "reference": "delete_node",
      "kind": "unknown",
      "id": 6,
      "text": "delete_node"
    },
    {
      "element type": "Array",
      "id": 7,
      "text": "[self, *delete_node]"
    },
    {
      "element type": "Else block",
      "id": 8
    },
    {
      "element type": "Pseudo constant",
      "id": 9,
      "text": "self"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 10,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 11,
      "operation type": "="
    },
    {
      "element type": "Assignment expression",
      "id": 12,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 13,
      "text": "deleted"
    },
    {
      "element type": "Instance variable",
      "id": 14,
      "text": "@left"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 15,
      "text": "rebalance"
    },
    {
      "element type": "Instance variable",
      "id": 16,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 17,
      "text": "@left.delete_min"
    },
    {
      "element type": "If statement",
      "id": 18
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 19,
      "text": "rebalance"
    },
    {
      "element type": "Compound statement",
      "id": 20,
      "text": "ret, rebalance = rebalance_for_left_delete"
    },
    {
      "element type": "Assignment expression",
      "id": 21,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 22,
      "text": "ret"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 23,
      "text": "rebalance"
    },
    {
      "element type": "Identifier rebalance_for_left_delete",
      "reference": "rebalance_for_left_delete",
      "kind": "unknown",
      "id": 24,
      "text": "rebalance_for_left_delete"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 25,
      "text": "deleted"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 26,
      "text": "ret"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 27,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 28,
      "text": "[deleted, ret, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 29,
      "text": "ret = self\n        deleted, @left, rebalance = @left.delete_min\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n        [deleted, ret, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 30,
      "text": "if @left.empty?\n        [self, *delete_node]\n      else\n        ret = self\n        deleted, @left, rebalance = @left.delete_min\n        if rebalance\n          ret, rebalance = rebalance_for_left_delete\n        end\n        [deleted, ret, rebalance]\n      end"
    },
    {
      "element type": "Body statement",
      "id": 31
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [
        4,
        8
      ]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [30]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [
        20,
        25
      ]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": []
    }
  ],
  "holder": "delete_min"
}



{
  "nodes description": [
    {
      "element type": "Pseudo constant",
      "id": 1,
      "text": "self"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 2,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 3,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 4,
      "text": "false"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 5,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 6,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 7
    },
    {
      "element type": "Fid",
      "id": 8,
      "text": "black?"
    },
    {
      "element type": "Compound statement",
      "id": 9,
      "text": "if @right.black?\n          if @right.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            @right.color = :RED\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            ret = balanced_rotate_left\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          ret = rotate_left\n          # try to rebalance in sub-tree\n          ret.left, rebalance = ret.left.rebalance_for_left_delete\n          raise 'should not happen' if rebalance\n        end"
    },
    {
      "element type": "If statement",
      "id": 10
    },
    {
      "element type": "Instance variable",
      "id": 11,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 12,
      "text": "@right.black?"
    },
    {
      "element type": "Compound statement",
      "id": 13,
      "text": "if @right.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            @right.color = :RED\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            ret = balanced_rotate_left\n          end"
    },
    {
      "element type": "If statement",
      "id": 14
    },
    {
      "element type": "Instance variable",
      "id": 15,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 16,
      "text": "@right.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 17,
      "text": "@right.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "@right.color = :RED\n            rebalance = true"
    },
    {
      "element type": "Instance variable",
      "id": 19,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 20,
      "text": "@right.color"
    },
    {
      "element type": "Assignment expression",
      "id": 21,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 22,
      "text": "true"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 23,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 24,
      "operation type": "="
    },
    {
      "element type": "Else block",
      "id": 25
    },
    {
      "element type": "Identifier balanced_rotate_left",
      "reference": "balanced_rotate_left",
      "kind": "unknown",
      "id": 26,
      "text": "balanced_rotate_left"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 27,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 28,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 29,
      "text": "ret = balanced_rotate_left"
    },
    {
      "element type": "Else block",
      "id": 30
    },
    {
      "element type": "Identifier rotate_left",
      "reference": "rotate_left",
      "kind": "unknown",
      "id": 31,
      "text": "rotate_left"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 32,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 33,
      "operation type": "="
    },
    {
      "element type": "Assignment expression",
      "id": 34,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 35,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 36,
      "text": "ret.left"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 37,
      "text": "rebalance"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 38,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 39,
      "text": "ret.left"
    },
    {
      "element type": "Reference",
      "id": 40,
      "text": "ret.left.rebalance_for_left_delete"
    },
    {
      "element type": "If mod statement",
      "id": 41
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 42,
      "text": "rebalance"
    },
    {
      "element type": "Call",
      "id": 43,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "String literal",
      "id": 44,
      "text": "'should not happen'",
      "value": "should not happen"
    },
    {
      "element type": "Call",
      "id": 45,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "Compound statement",
      "id": 46,
      "text": "ret = rotate_left\n          # try to rebalance in sub-tree\n          ret.left, rebalance = ret.left.rebalance_for_left_delete\n          raise 'should not happen' if rebalance"
    },
    {
      "element type": "Else block",
      "id": 47
    },
    {
      "element type": "If statement",
      "id": 48
    },
    {
      "element type": "Instance variable",
      "id": 49,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 50,
      "text": "@right.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 51,
      "text": "@right.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 52,
      "text": "color_flip(@right)"
    },
    {
      "element type": "Instance variable",
      "id": 53,
      "text": "@right"
    },
    {
      "element type": "Call",
      "callee": "color_flip",
      "id": 54,
      "text": "color_flip(@right)"
    },
    {
      "element type": "Else block",
      "id": 55
    },
    {
      "element type": "Identifier balanced_rotate_left",
      "reference": "balanced_rotate_left",
      "kind": "unknown",
      "id": 56,
      "text": "balanced_rotate_left"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 57,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 58,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 59,
      "text": "ret = balanced_rotate_left"
    },
    {
      "element type": "Compound statement",
      "id": 60,
      "text": "if @right.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          color_flip(@right)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          ret = balanced_rotate_left\n        end"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 61,
      "text": "ret"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 62,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 63,
      "text": "[ret, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 64,
      "text": "ret = self\n      rebalance = false\n      if black?\n        if @right.black?\n          if @right.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            @right.color = :RED\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            ret = balanced_rotate_left\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          ret = rotate_left\n          # try to rebalance in sub-tree\n          ret.left, rebalance = ret.left.rebalance_for_left_delete\n          raise 'should not happen' if rebalance\n        end\n      else # red\n        if @right.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          color_flip(@right)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          ret = balanced_rotate_left\n        end\n      end\n      [ret, rebalance]"
    },
    {
      "element type": "Body statement",
      "id": 65
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [
        9,
        47
      ]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [
        13,
        30
      ]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [
        18,
        25
      ]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [61]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [61]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [
        43,
        46
      ]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": []
    },
    {
      "from": 46,
      "to": [61]
    },
    {
      "from": 47,
      "to": [48]
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [
        52,
        55
      ]
    },
    {
      "from": 52,
      "to": [53]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [60]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [65]
    },
    {
      "from": 65,
      "to": [66]
    },
    {
      "from": 66,
      "to": []
    }
  ],
  "holder": "rebalance_for_left_delete"
}



{
  "nodes description": [
    {
      "element type": "Pseudo constant",
      "id": 1,
      "text": "self"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 2,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 3,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 4,
      "text": "false"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 5,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 6,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 7
    },
    {
      "element type": "Fid",
      "id": 8,
      "text": "black?"
    },
    {
      "element type": "Compound statement",
      "id": 9,
      "text": "if @left.black?\n          if @left.children_color?(:BLACK)\n            @left.color = :RED\n            rebalance = true\n          else\n            ret = balanced_rotate_right\n          end\n        else\n          ret = rotate_right\n          ret.right, rebalance = ret.right.rebalance_for_right_delete\n          raise 'should not happen' if rebalance\n        end"
    },
    {
      "element type": "If statement",
      "id": 10
    },
    {
      "element type": "Instance variable",
      "id": 11,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 12,
      "text": "@left.black?"
    },
    {
      "element type": "Compound statement",
      "id": 13,
      "text": "if @left.children_color?(:BLACK)\n            @left.color = :RED\n            rebalance = true\n          else\n            ret = balanced_rotate_right\n          end"
    },
    {
      "element type": "If statement",
      "id": 14
    },
    {
      "element type": "Instance variable",
      "id": 15,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 16,
      "text": "@left.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 17,
      "text": "@left.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "@left.color = :RED\n            rebalance = true"
    },
    {
      "element type": "Instance variable",
      "id": 19,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 20,
      "text": "@left.color"
    },
    {
      "element type": "Assignment expression",
      "id": 21,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 22,
      "text": "true"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 23,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 24,
      "operation type": "="
    },
    {
      "element type": "Else block",
      "id": 25
    },
    {
      "element type": "Identifier balanced_rotate_right",
      "reference": "balanced_rotate_right",
      "kind": "unknown",
      "id": 26,
      "text": "balanced_rotate_right"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 27,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 28,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 29,
      "text": "ret = balanced_rotate_right"
    },
    {
      "element type": "Else block",
      "id": 30
    },
    {
      "element type": "Identifier rotate_right",
      "reference": "rotate_right",
      "kind": "unknown",
      "id": 31,
      "text": "rotate_right"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 32,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 33,
      "operation type": "="
    },
    {
      "element type": "Assignment expression",
      "id": 34,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 35,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 36,
      "text": "ret.right"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 37,
      "text": "rebalance"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 38,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 39,
      "text": "ret.right"
    },
    {
      "element type": "Reference",
      "id": 40,
      "text": "ret.right.rebalance_for_right_delete"
    },
    {
      "element type": "If mod statement",
      "id": 41
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 42,
      "text": "rebalance"
    },
    {
      "element type": "Call",
      "id": 43,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "String literal",
      "id": 44,
      "text": "'should not happen'",
      "value": "should not happen"
    },
    {
      "element type": "Call",
      "id": 45,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "Compound statement",
      "id": 46,
      "text": "ret = rotate_right\n          ret.right, rebalance = ret.right.rebalance_for_right_delete\n          raise 'should not happen' if rebalance"
    },
    {
      "element type": "Else block",
      "id": 47
    },
    {
      "element type": "If statement",
      "id": 48
    },
    {
      "element type": "Instance variable",
      "id": 49,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 50,
      "text": "@left.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 51,
      "text": "@left.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 52,
      "text": "color_flip(@left)"
    },
    {
      "element type": "Instance variable",
      "id": 53,
      "text": "@left"
    },
    {
      "element type": "Call",
      "callee": "color_flip",
      "id": 54,
      "text": "color_flip(@left)"
    },
    {
      "element type": "Else block",
      "id": 55
    },
    {
      "element type": "Identifier balanced_rotate_right",
      "reference": "balanced_rotate_right",
      "kind": "unknown",
      "id": 56,
      "text": "balanced_rotate_right"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 57,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 58,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 59,
      "text": "ret = balanced_rotate_right"
    },
    {
      "element type": "Compound statement",
      "id": 60,
      "text": "if @left.children_color?(:BLACK)\n          color_flip(@left)\n        else\n          ret = balanced_rotate_right\n        end"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 61,
      "text": "ret"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 62,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 63,
      "text": "[ret, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 64,
      "text": "ret = self\n      rebalance = false\n      if black?\n        if @left.black?\n          if @left.children_color?(:BLACK)\n            @left.color = :RED\n            rebalance = true\n          else\n            ret = balanced_rotate_right\n          end\n        else\n          ret = rotate_right\n          ret.right, rebalance = ret.right.rebalance_for_right_delete\n          raise 'should not happen' if rebalance\n        end\n      else # red\n        if @left.children_color?(:BLACK)\n          color_flip(@left)\n        else\n          ret = balanced_rotate_right\n        end\n      end\n      [ret, rebalance]"
    },
    {
      "element type": "Body statement",
      "id": 65
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [
        9,
        47
      ]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [
        13,
        30
      ]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [
        18,
        25
      ]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [61]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [61]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [
        43,
        46
      ]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": []
    },
    {
      "from": 46,
      "to": [61]
    },
    {
      "from": 47,
      "to": [48]
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [
        52,
        55
      ]
    },
    {
      "from": 52,
      "to": [53]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [60]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [65]
    },
    {
      "from": 65,
      "to": [66]
    },
    {
      "from": 66,
      "to": []
    }
  ],
  "holder": "rebalance_for_right_delete"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@right.left"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "@right.left.red?"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 8,
      "text": "@right.right"
    },
    {
      "element type": "Reference",
      "id": 9,
      "text": "@right.right.black?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 10,
      "text": "@right.left.red? and @right.right.black?"
    },
    {
      "element type": "Compound statement",
      "id": 11,
      "text": "@right = @right.rotate_right"
    },
    {
      "element type": "Instance variable",
      "id": 12,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "@right.rotate_right"
    },
    {
      "element type": "Instance variable",
      "id": 14,
      "text": "@right"
    },
    {
      "element type": "Assignment expression",
      "id": 15,
      "operation type": "="
    },
    {
      "element type": "Identifier rotate_left",
      "reference": "rotate_left",
      "kind": "unknown",
      "id": 16,
      "text": "rotate_left"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 17,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 18,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 19,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 20,
      "text": "ret.left"
    },
    {
      "element type": "Reference",
      "id": 21,
      "text": "ret.left.color"
    },
    {
      "element type": "Assignment expression",
      "id": 22,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 23,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 24,
      "text": "ret.right"
    },
    {
      "element type": "Reference",
      "id": 25,
      "text": "ret.right.color"
    },
    {
      "element type": "Assignment expression",
      "id": 26,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 27,
      "text": "ret"
    },
    {
      "element type": "Compound statement",
      "id": 28,
      "text": "if @right.left.red? and @right.right.black?\n        @right = @right.rotate_right\n      end\n      ret = rotate_left\n      ret.right.color = ret.left.color = :BLACK\n      ret"
    },
    {
      "element type": "Body statement",
      "id": 29
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [
        5,
        6
      ]
    },
    {
      "from": 5,
      "to": [7]
    },
    {
      "from": 6,
      "to": [16]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [
        11,
        16
      ]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": []
    }
  ],
  "holder": "balanced_rotate_left"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@left.right"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "@left.right.red?"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 8,
      "text": "@left.left"
    },
    {
      "element type": "Reference",
      "id": 9,
      "text": "@left.left.black?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 10,
      "text": "@left.right.red? and @left.left.black?"
    },
    {
      "element type": "Compound statement",
      "id": 11,
      "text": "@left = @left.rotate_left"
    },
    {
      "element type": "Instance variable",
      "id": 12,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "@left.rotate_left"
    },
    {
      "element type": "Instance variable",
      "id": 14,
      "text": "@left"
    },
    {
      "element type": "Assignment expression",
      "id": 15,
      "operation type": "="
    },
    {
      "element type": "Identifier rotate_right",
      "reference": "rotate_right",
      "kind": "unknown",
      "id": 16,
      "text": "rotate_right"
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 17,
      "text": "ret"
    },
    {
      "element type": "Assignment expression",
      "id": 18,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 19,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 20,
      "text": "ret.left"
    },
    {
      "element type": "Reference",
      "id": 21,
      "text": "ret.left.color"
    },
    {
      "element type": "Assignment expression",
      "id": 22,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 23,
      "text": "ret"
    },
    {
      "element type": "Reference",
      "id": 24,
      "text": "ret.right"
    },
    {
      "element type": "Reference",
      "id": 25,
      "text": "ret.right.color"
    },
    {
      "element type": "Assignment expression",
      "id": 26,
      "operation type": "="
    },
    {
      "element type": "Identifier ret",
      "reference": "ret",
      "kind": "local variable",
      "id": 27,
      "text": "ret"
    },
    {
      "element type": "Compound statement",
      "id": 28,
      "text": "if @left.right.red? and @left.left.black?\n        @left = @left.rotate_left\n      end\n      ret = rotate_right\n      ret.right.color = ret.left.color = :BLACK\n      ret"
    },
    {
      "element type": "Body statement",
      "id": 29
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [
        5,
        6
      ]
    },
    {
      "from": 5,
      "to": [7]
    },
    {
      "from": 6,
      "to": [16]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [
        11,
        16
      ]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": []
    }
  ],
  "holder": "balanced_rotate_right"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@right"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 2,
      "text": "root"
    },
    {
      "element type": "Assignment expression",
      "id": 3,
      "operation type": "="
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 4,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 5,
      "text": "root.left"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@right"
    },
    {
      "element type": "Assignment expression",
      "id": 7,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 8,
      "text": "self"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 9,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 10,
      "text": "root.left"
    },
    {
      "element type": "Assignment expression",
      "id": 11,
      "operation type": "="
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 12,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "root.color_flip"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 14,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 15,
      "text": "root.left"
    },
    {
      "element type": "Call",
      "callee": "color_flip",
      "id": 16,
      "text": "root.color_flip(root.left)"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 17,
      "text": "root"
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "root = @right\n      @right = root.left\n      root.left = self\n      root.color_flip(root.left)\n      root"
    },
    {
      "element type": "Body statement",
      "id": 19
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": []
    }
  ],
  "holder": "rotate_left"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@left"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 2,
      "text": "root"
    },
    {
      "element type": "Assignment expression",
      "id": 3,
      "operation type": "="
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 4,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 5,
      "text": "root.right"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@left"
    },
    {
      "element type": "Assignment expression",
      "id": 7,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 8,
      "text": "self"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 9,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 10,
      "text": "root.right"
    },
    {
      "element type": "Assignment expression",
      "id": 11,
      "operation type": "="
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 12,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "root.color_flip"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 14,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 15,
      "text": "root.right"
    },
    {
      "element type": "Call",
      "callee": "color_flip",
      "id": 16,
      "text": "root.color_flip(root.right)"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 17,
      "text": "root"
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "root = @left\n      @left = root.right\n      root.right = self\n      root.color_flip(root.right)\n      root"
    },
    {
      "element type": "Body statement",
      "id": 19
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": []
    }
  ],
  "holder": "rotate_right"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Fid",
      "id": 2,
      "text": "black?"
    },
    {
      "element type": "Fid",
      "id": 5,
      "text": "children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 6,
      "text": "children_color?(:RED)"
    },
    {
      "element type": "Boolean binary expression",
      "id": 7,
      "text": "black? and children_color?(:RED)"
    },
    {
      "element type": "Compound statement",
      "id": 8,
      "text": "@left.color = @right.color = :BLACK\n        self.color = :RED"
    },
    {
      "element type": "Instance variable",
      "id": 9,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 10,
      "text": "@right.color"
    },
    {
      "element type": "Assignment expression",
      "id": 11,
      "operation type": "="
    },
    {
      "element type": "Instance variable",
      "id": 12,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "@left.color"
    },
    {
      "element type": "Assignment expression",
      "id": 14,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 15,
      "text": "self"
    },
    {
      "element type": "Reference",
      "id": 16,
      "text": "self.color"
    },
    {
      "element type": "Assignment expression",
      "id": 17,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 18,
      "text": "self"
    },
    {
      "element type": "Compound statement",
      "id": 19,
      "text": "if black? and children_color?(:RED)\n        @left.color = @right.color = :BLACK\n        self.color = :RED\n      end\n      self"
    },
    {
      "element type": "Body statement",
      "id": 20
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [
        3,
        4
      ]
    },
    {
      "from": 3,
      "to": [5]
    },
    {
      "from": 4,
      "to": [18]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [
        8,
        18
      ]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": []
    }
  ],
  "holder": "pullup_red"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@left.right"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "@left.right.red?"
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "@left = @left.rotate_left"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 7,
      "text": "@left.rotate_left"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@left"
    },
    {
      "element type": "Assignment expression",
      "id": 9,
      "operation type": "="
    },
    {
      "element type": "Identifier rotate_right",
      "reference": "rotate_right",
      "kind": "unknown",
      "id": 10,
      "text": "rotate_right"
    },
    {
      "element type": "Compound statement",
      "id": 11,
      "text": "if @left.right.red?\n        @left = @left.rotate_left\n      end\n      rotate_right"
    },
    {
      "element type": "Body statement",
      "id": 12
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [
        5,
        10
      ]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": []
    }
  ],
  "holder": "rebalance_for_left_insert"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@right.left"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "@right.left.red?"
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "@right = @right.rotate_right"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 7,
      "text": "@right.rotate_right"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@right"
    },
    {
      "element type": "Assignment expression",
      "id": 9,
      "operation type": "="
    },
    {
      "element type": "Identifier rotate_left",
      "reference": "rotate_left",
      "kind": "unknown",
      "id": 10,
      "text": "rotate_left"
    },
    {
      "element type": "Compound statement",
      "id": 11,
      "text": "if @right.left.red?\n        @right = @right.rotate_right\n      end\n      rotate_left"
    },
    {
      "element type": "Body statement",
      "id": 12
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [
        5,
        10
      ]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": []
    }
  ],
  "holder": "rebalance_for_right_insert"
}



{
  "nodes description": [
    {
      "element type": "Pseudo constant",
      "id": 1,
      "text": "false"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 2,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 3,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 4
    },
    {
      "element type": "Instance variable",
      "id": 5,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 6,
      "text": "@left.empty?"
    },
    {
      "element type": "Instance variable",
      "id": 9,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 10,
      "text": "@right.empty?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 11,
      "text": "@left.empty? and @right.empty?"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "new_root = EMPTY\n        if black?\n          rebalance = true\n        end"
    },
    {
      "element type": "Constant",
      "id": 13,
      "text": "EMPTY"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 14,
      "text": "new_root"
    },
    {
      "element type": "Assignment expression",
      "id": 15,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 16
    },
    {
      "element type": "Fid",
      "id": 17,
      "text": "black?"
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "rebalance = true"
    },
    {
      "element type": "Pseudo constant",
      "id": 19,
      "text": "true"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 20,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 21,
      "operation type": "="
    },
    {
      "element type": "Instance variable",
      "id": 22,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 23,
      "text": "@left.empty?"
    },
    {
      "element type": "Instance variable",
      "id": 26,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 27,
      "text": "@right.empty?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 28,
      "text": "@left.empty? or @right.empty?"
    },
    {
      "element type": "Compound statement",
      "id": 29,
      "text": "new_root = EMPTY\n        if black?\n          rebalance = true\n        end"
    },
    {
      "element type": "Ternary expression",
      "id": 30
    },
    {
      "element type": "Instance variable",
      "id": 31,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 32,
      "text": "@left.empty?"
    },
    {
      "element type": "Instance variable",
      "id": 33,
      "text": "@right"
    },
    {
      "element type": "Instance variable",
      "id": 34,
      "text": "@right"
    },
    {
      "element type": "Instance variable",
      "id": 35,
      "text": "@left"
    },
    {
      "element type": "Instance variable",
      "id": 36,
      "text": "@left"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 37,
      "text": "new_root"
    },
    {
      "element type": "Assignment expression",
      "id": 38,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 39
    },
    {
      "element type": "Fid",
      "id": 40,
      "text": "black?"
    },
    {
      "element type": "Compound statement",
      "id": 41,
      "text": "raise 'should not happen' unless new_root.red?\n          color_flip(new_root)"
    },
    {
      "element type": "Unless mod statement",
      "id": 42
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 43,
      "text": "new_root"
    },
    {
      "element type": "Reference",
      "id": 44,
      "text": "new_root.red?"
    },
    {
      "element type": "Call",
      "id": 45,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "String literal",
      "id": 46,
      "text": "'should not happen'",
      "value": "should not happen"
    },
    {
      "element type": "Call",
      "id": 47,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 48,
      "text": "new_root"
    },
    {
      "element type": "Call",
      "callee": "color_flip",
      "id": 49,
      "text": "color_flip(new_root)"
    },
    {
      "element type": "Else block",
      "id": 50
    },
    {
      "element type": "Compound statement",
      "id": 51,
      "text": ""
    },
    {
      "element type": "Compound statement",
      "id": 52,
      "text": "new_root = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_root.red?\n          color_flip(new_root)\n        else\n          # just remove the red node\n        end"
    },
    {
      "element type": "Else block",
      "id": 53
    },
    {
      "element type": "Assignment expression",
      "id": 54,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 55,
      "text": "deleted"
    },
    {
      "element type": "Instance variable",
      "id": 56,
      "text": "@right"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 57,
      "text": "rebalance"
    },
    {
      "element type": "Instance variable",
      "id": 58,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 59,
      "text": "@right.delete_min"
    },
    {
      "element type": "Constant",
      "id": 60,
      "text": "Node"
    },
    {
      "element type": "Reference",
      "id": 61,
      "text": "Node.new"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 62,
      "text": "deleted"
    },
    {
      "element type": "Reference",
      "id": 63,
      "text": "deleted.key"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 64,
      "text": "deleted"
    },
    {
      "element type": "Reference",
      "id": 65,
      "text": "deleted.value"
    },
    {
      "element type": "Instance variable",
      "id": 66,
      "text": "@left"
    },
    {
      "element type": "Instance variable",
      "id": 67,
      "text": "@right"
    },
    {
      "element type": "Instance variable",
      "id": 68,
      "text": "@color"
    },
    {
      "element type": "Call",
      "call type": "RedBlackTree::Node",
      "callee": "initialize",
      "id": 69,
      "text": "Node.new(deleted.key, deleted.value, @left, @right, @color)"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 70,
      "text": "new_root"
    },
    {
      "element type": "Assignment expression",
      "id": 71,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 72
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 73,
      "text": "rebalance"
    },
    {
      "element type": "Compound statement",
      "id": 74,
      "text": "new_root, rebalance = new_root.rebalance_for_right_delete"
    },
    {
      "element type": "Assignment expression",
      "id": 75,
      "operation type": "="
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 76,
      "text": "new_root"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 77,
      "text": "rebalance"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 78,
      "text": "new_root"
    },
    {
      "element type": "Reference",
      "id": 79,
      "text": "new_root.rebalance_for_right_delete"
    },
    {
      "element type": "Compound statement",
      "id": 80,
      "text": "deleted, @right, rebalance = @right.delete_min\n        new_root = Node.new(deleted.key, deleted.value, @left, @right, @color)\n        if rebalance\n          new_root, rebalance = new_root.rebalance_for_right_delete\n        end"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 81,
      "text": "new_root"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 82,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 83,
      "text": "[new_root, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 84,
      "text": "rebalance = false\n      if @left.empty? and @right.empty?\n        # just remove this node and ask rebalance to the parent\n        new_root = EMPTY\n        if black?\n          rebalance = true\n        end\n      elsif @left.empty? or @right.empty?\n        # pick the single children\n        new_root = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_root.red?\n          color_flip(new_root)\n        else\n          # just remove the red node\n        end\n      else\n        # pick the minimum node from the right sub-tree and replace self with it\n        deleted, @right, rebalance = @right.delete_min\n        new_root = Node.new(deleted.key, deleted.value, @left, @right, @color)\n        if rebalance\n          new_root, rebalance = new_root.rebalance_for_right_delete\n        end\n      end\n      [new_root, rebalance]"
    },
    {
      "element type": "Body statement",
      "id": 85
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [
        7,
        8
      ]
    },
    {
      "from": 7,
      "to": [9]
    },
    {
      "from": 8,
      "to": [22]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [
        12,
        22
      ]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [
        18,
        81
      ]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [81]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [
        24,
        25
      ]
    },
    {
      "from": 24,
      "to": [29]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [
        29,
        53
      ]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [
        33,
        35
      ]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [37]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [
        41,
        50
      ]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [43]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [
        45,
        48
      ]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": []
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [52]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [81]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [55]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [65]
    },
    {
      "from": 65,
      "to": [66]
    },
    {
      "from": 66,
      "to": [67]
    },
    {
      "from": 67,
      "to": [68]
    },
    {
      "from": 68,
      "to": [69]
    },
    {
      "from": 69,
      "to": [70]
    },
    {
      "from": 70,
      "to": [71]
    },
    {
      "from": 71,
      "to": [72]
    },
    {
      "from": 72,
      "to": [73]
    },
    {
      "from": 73,
      "to": [
        74,
        80
      ]
    },
    {
      "from": 74,
      "to": [75]
    },
    {
      "from": 75,
      "to": [76]
    },
    {
      "from": 76,
      "to": [77]
    },
    {
      "from": 77,
      "to": [78]
    },
    {
      "from": 78,
      "to": [79]
    },
    {
      "from": 79,
      "to": [80]
    },
    {
      "from": 80,
      "to": [81]
    },
    {
      "from": 81,
      "to": [82]
    },
    {
      "from": 82,
      "to": [83]
    },
    {
      "from": 83,
      "to": [84]
    },
    {
      "from": 84,
      "to": [85]
    },
    {
      "from": 85,
      "to": [86]
    },
    {
      "from": 86,
      "to": []
    }
  ],
  "holder": "delete_node"
}



{
  "nodes description": [
    {
      "element type": "Array",
      "id": 1,
      "text": "[]"
    },
    {
      "element type": "Identifier pool",
      "reference": "pool",
      "kind": "local variable",
      "id": 2,
      "text": "pool"
    },
    {
      "element type": "Assignment expression",
      "id": 3,
      "operation type": "="
    },
    {
      "element type": "Identifier each",
      "reference": "each",
      "kind": "unknown",
      "id": 4,
      "text": "each"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "block parameter declaration",
      "id": 5,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "block parameter declaration",
      "id": 6,
      "text": "value"
    },
    {
      "element type": "Identifier pool",
      "reference": "pool",
      "kind": "local variable",
      "id": 7,
      "text": "pool"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 8,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 9,
      "text": "value"
    },
    {
      "element type": "Yield statement",
      "id": 10
    },
    {
      "element type": "Binary expression",
      "id": 11,
      "text": "pool << yield(key, value)",
      "expression type": "Integer",
      "operation type": "<<"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "pool << yield(key, value)"
    },
    {
      "element type": "Body statement",
      "id": 13
    },
    {
      "element type": "Code block",
      "id": 14
    },
    {
      "element type": "Block call",
      "id": 15
    },
    {
      "element type": "Identifier pool",
      "reference": "pool",
      "kind": "local variable",
      "id": 16,
      "text": "pool"
    },
    {
      "element type": "Compound statement",
      "id": 17,
      "text": "pool = []\n      each do |key, value|\n        pool << yield(key, value)\n      end\n      pool"
    },
    {
      "element type": "Body statement",
      "id": 18
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [
        5,
        15
      ]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [
        15,
        5
      ]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": []
    }
  ],
  "holder": "collect"
}



{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "EmptyNode"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "Node"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "def initialize\n        @value = nil\n        @color = :BLACK\n      end\n\n      def empty?\n        true\n      end\n\n      def size\n        0\n      end\n\n      def each(&block)\n        # intentionally blank\n      end\n\n      # returns new_root\n      def insert(key, value)\n        Node.new(key, value, self, self)\n      end\n\n      # returns value\n      def retrieve(key)\n        UNDEFINED\n      end\n\n      # returns [deleted_node, new_root, is_rebalance_needed]\n      def delete(key)\n        [self, self, false]\n      end\n\n      def dump_tree(io, indent = '')\n        # intentionally blank\n      end\n\n      def dump_sexp\n        # intentionally blank\n      end"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "EmptyNode"
}


{
  "nodes description": [
    {
      "element type": "Pseudo constant",
      "id": 1,
      "text": "nil"
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@value"
    },
    {
      "element type": "Assignment expression",
      "id": 3,
      "operation type": "="
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@color"
    },
    {
      "element type": "Assignment expression",
      "id": 5,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 6,
      "text": "@value = nil\n        @color = :BLACK"
    },
    {
      "element type": "Body statement",
      "id": 7
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": []
    }
  ],
  "holder": "initialize"
}



{
  "nodes description": [
    {
      "element type": "Pseudo constant",
      "id": 1,
      "text": "true"
    },
    {
      "element type": "Compound statement",
      "id": 2,
      "text": "true"
    },
    {
      "element type": "Body statement",
      "id": 3
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": []
    }
  ],
  "holder": "empty?"
}



{
  "nodes description": [
    {
      "element type": "Integer constant",
      "id": 1,
      "text": "0"
    },
    {
      "element type": "Compound statement",
      "id": 2,
      "text": "0"
    },
    {
      "element type": "Body statement",
      "id": 3
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": []
    }
  ],
  "holder": "size"
}



{
  "nodes description": [
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "block"
    },
    {
      "element type": "Compound statement",
      "id": 2,
      "text": ""
    },
    {
      "element type": "Body statement",
      "id": 3
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": []
    }
  ],
  "holder": "each"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "value"
    },
    {
      "element type": "Constant",
      "id": 3,
      "text": "Node"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "Node.new"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 5,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 6,
      "text": "value"
    },
    {
      "element type": "Pseudo constant",
      "id": 7,
      "text": "self"
    },
    {
      "element type": "Pseudo constant",
      "id": 8,
      "text": "self"
    },
    {
      "element type": "Call",
      "call type": "RedBlackTree::Node",
      "callee": "initialize",
      "id": 9,
      "text": "Node.new(key, value, self, self)"
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "Node.new(key, value, self, self)"
    },
    {
      "element type": "Body statement",
      "id": 11
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": []
    }
  ],
  "holder": "insert"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "UNDEFINED"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "UNDEFINED"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "retrieve"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Pseudo constant",
      "id": 2,
      "text": "self"
    },
    {
      "element type": "Pseudo constant",
      "id": 3,
      "text": "self"
    },
    {
      "element type": "Pseudo constant",
      "id": 4,
      "text": "false"
    },
    {
      "element type": "Array",
      "id": 5,
      "text": "[self, self, false]"
    },
    {
      "element type": "Compound statement",
      "id": 6,
      "text": "[self, self, false]"
    },
    {
      "element type": "Body statement",
      "id": 7
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": []
    }
  ],
  "holder": "delete"
}



{
  "nodes description": [
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "io"
    },
    {
      "element type": "String literal",
      "id": 2,
      "text": "''",
      "value": ""
    },
    {
      "element type": "Identifier indent",
      "reference": "indent",
      "kind": "method parameter declaration",
      "id": 3,
      "text": "indent"
    },
    {
      "element type": "Compound statement",
      "id": 4,
      "text": ""
    },
    {
      "element type": "Body statement",
      "id": 5
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": []
    }
  ],
  "holder": "dump_tree"
}



{
  "nodes description": [
    {
      "element type": "Compound statement",
      "id": 1,
      "text": ""
    },
    {
      "element type": "Body statement",
      "id": 2
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": []
    }
  ],
  "holder": "dump_sexp"
}



{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "DEFAULT"
    },
    {
      "element type": "Identifier default",
      "reference": "default",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "default"
    },
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "method parameter declaration",
      "id": 3,
      "text": "block"
    },
    {
      "element type": "If statement",
      "id": 4
    },
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "local variable",
      "id": 5,
      "text": "block"
    },
    {
      "element type": "Identifier default",
      "reference": "default",
      "kind": "local variable",
      "id": 8,
      "text": "default"
    },
    {
      "element type": "Constant",
      "id": 9,
      "text": "DEFAULT"
    },
    {
      "element type": "Binary expression",
      "id": 10,
      "text": "default != DEFAULT",
      "expression type": "TrueClass or FalseClass",
      "operation type": "!="
    },
    {
      "element type": "Boolean binary expression",
      "id": 11,
      "text": "block && default != DEFAULT"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "raise ArgumentError, 'wrong number of arguments'"
    },
    {
      "element type": "Constant",
      "id": 13,
      "text": "ArgumentError"
    },
    {
      "element type": "String literal",
      "id": 14,
      "text": "'wrong number of arguments'",
      "value": "wrong number of arguments"
    },
    {
      "element type": "Call",
      "id": 15,
      "text": "raise ArgumentError, 'wrong number of arguments'"
    },
    {
      "element type": "Constant",
      "id": 16,
      "text": "Node"
    },
    {
      "element type": "Colon reference",
      "id": 17,
      "text": "Node::EMPTY"
    },
    {
      "element type": "Instance variable",
      "id": 18,
      "text": "@root"
    },
    {
      "element type": "Assignment expression",
      "id": 19,
      "operation type": "="
    },
    {
      "element type": "Identifier default",
      "reference": "default",
      "kind": "local variable",
      "id": 20,
      "text": "default"
    },
    {
      "element type": "Instance variable",
      "id": 21,
      "text": "@default"
    },
    {
      "element type": "Assignment expression",
      "id": 22,
      "operation type": "="
    },
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "local variable",
      "id": 23,
      "text": "block"
    },
    {
      "element type": "Instance variable",
      "id": 24,
      "text": "@default_proc"
    },
    {
      "element type": "Assignment expression",
      "id": 25,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 26,
      "text": "if block && default != DEFAULT\n      raise ArgumentError, 'wrong number of arguments'\n    end\n    @root = Node::EMPTY\n    @default = default\n    @default_proc = block"
    },
    {
      "element type": "Body statement",
      "id": 27
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [
        6,
        7
      ]
    },
    {
      "from": 6,
      "to": [8]
    },
    {
      "from": 7,
      "to": [16]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [
        12,
        16
      ]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": []
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": []
    }
  ],
  "holder": "initialize"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@root"
    },
    {
      "element type": "Compound statement",
      "id": 2,
      "text": "@root"
    },
    {
      "element type": "Body statement",
      "id": 3
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": []
    }
  ],
  "holder": "root"
}



{
  "nodes description": [
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 1,
      "text": "root"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "Node"
    },
    {
      "element type": "Colon reference",
      "id": 3,
      "text": "Node::EMPTY"
    },
    {
      "element type": "Binary expression",
      "id": 4,
      "text": "root == Node::EMPTY",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "root == Node::EMPTY"
    },
    {
      "element type": "Body statement",
      "id": 6
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": []
    }
  ],
  "holder": "empty?"
}



{
  "nodes description": [
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 1,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 2,
      "text": "root.size"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "root.size"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "size"
}



{
  "nodes description": [
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "block"
    },
    {
      "element type": "If statement",
      "id": 2
    },
    {
      "element type": "Fid",
      "id": 3,
      "text": "block_given?"
    },
    {
      "element type": "Compound statement",
      "id": 4,
      "text": "root.each(&block)\n      self"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 5,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 6,
      "text": "root.each"
    },
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "local variable",
      "id": 7,
      "text": "block"
    },
    {
      "element type": "Call",
      "id": 8,
      "text": "root.each(&block)"
    },
    {
      "element type": "Pseudo constant",
      "id": 9,
      "text": "self"
    },
    {
      "element type": "Else block",
      "id": 10
    },
    {
      "element type": "Constant",
      "id": 11,
      "text": "Enumerator"
    },
    {
      "element type": "Reference",
      "id": 12,
      "text": "Enumerator.new"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 13,
      "text": "root"
    },
    {
      "element type": "Call",
      "id": 14,
      "text": "Enumerator.new(root)"
    },
    {
      "element type": "Compound statement",
      "id": 15,
      "text": "Enumerator.new(root)"
    },
    {
      "element type": "Compound statement",
      "id": 16,
      "text": "if block_given?\n      root.each(&block)\n      self\n    else\n      Enumerator.new(root)\n    end"
    },
    {
      "element type": "Body statement",
      "id": 17
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [
        4,
        10
      ]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [16]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": []
    }
  ],
  "holder": "each"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Fid",
      "id": 2,
      "text": "block_given?"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "root.each do |k, v|\n        yield k\n      end\n      self"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 4,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 5,
      "text": "root.each"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "block parameter declaration",
      "id": 6,
      "text": "k"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "block parameter declaration",
      "id": 7,
      "text": "v"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "local variable",
      "id": 8,
      "text": "k"
    },
    {
      "element type": "Yield statement",
      "id": 9
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "yield k"
    },
    {
      "element type": "Body statement",
      "id": 11
    },
    {
      "element type": "Code block",
      "id": 12
    },
    {
      "element type": "Block call",
      "id": 13
    },
    {
      "element type": "Pseudo constant",
      "id": 14,
      "text": "self"
    },
    {
      "element type": "Else block",
      "id": 15
    },
    {
      "element type": "Constant",
      "id": 16,
      "text": "Enumerator"
    },
    {
      "element type": "Reference",
      "id": 17,
      "text": "Enumerator.new"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 18,
      "text": "root"
    },
    {
      "element type": "Call",
      "id": 19,
      "text": "Enumerator.new(root, :each_key)"
    },
    {
      "element type": "Compound statement",
      "id": 20,
      "text": "Enumerator.new(root, :each_key)"
    },
    {
      "element type": "Compound statement",
      "id": 21,
      "text": "if block_given?\n      root.each do |k, v|\n        yield k\n      end\n      self\n    else\n      Enumerator.new(root, :each_key)\n    end"
    },
    {
      "element type": "Body statement",
      "id": 22
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [
        3,
        15
      ]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [
        6,
        13
      ]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [
        13,
        6
      ]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [21]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": []
    }
  ],
  "holder": "each_key"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Fid",
      "id": 2,
      "text": "block_given?"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "root.each do |k, v|\n        yield v\n      end\n      self"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 4,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 5,
      "text": "root.each"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "block parameter declaration",
      "id": 6,
      "text": "k"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "block parameter declaration",
      "id": 7,
      "text": "v"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "local variable",
      "id": 8,
      "text": "v"
    },
    {
      "element type": "Yield statement",
      "id": 9
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "yield v"
    },
    {
      "element type": "Body statement",
      "id": 11
    },
    {
      "element type": "Code block",
      "id": 12
    },
    {
      "element type": "Block call",
      "id": 13
    },
    {
      "element type": "Pseudo constant",
      "id": 14,
      "text": "self"
    },
    {
      "element type": "Else block",
      "id": 15
    },
    {
      "element type": "Constant",
      "id": 16,
      "text": "Enumerator"
    },
    {
      "element type": "Reference",
      "id": 17,
      "text": "Enumerator.new"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 18,
      "text": "root"
    },
    {
      "element type": "Call",
      "id": 19,
      "text": "Enumerator.new(root, :each_value)"
    },
    {
      "element type": "Compound statement",
      "id": 20,
      "text": "Enumerator.new(root, :each_value)"
    },
    {
      "element type": "Compound statement",
      "id": 21,
      "text": "if block_given?\n      root.each do |k, v|\n        yield v\n      end\n      self\n    else\n      Enumerator.new(root, :each_value)\n    end"
    },
    {
      "element type": "Body statement",
      "id": 22
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [
        3,
        15
      ]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [
        6,
        13
      ]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [
        13,
        6
      ]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [21]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": []
    }
  ],
  "holder": "each_value"
}



{
  "nodes description": [
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 1,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 2,
      "text": "root.keys"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "root.keys"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "keys"
}



{
  "nodes description": [
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 1,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 2,
      "text": "root.values"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "root.values"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "values"
}



{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "Node"
    },
    {
      "element type": "Colon reference",
      "id": 2,
      "text": "Node::EMPTY"
    },
    {
      "element type": "Instance variable",
      "id": 3,
      "text": "@root"
    },
    {
      "element type": "Assignment expression",
      "id": 4,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "@root = Node::EMPTY"
    },
    {
      "element type": "Body statement",
      "id": 6
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": []
    }
  ],
  "holder": "clear"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "value"
    },
    {
      "element type": "Instance variable",
      "id": 3,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "@root.insert"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 5,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 6,
      "text": "value"
    },
    {
      "element type": "Call",
      "id": 7,
      "text": "@root.insert(key, value)"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@root"
    },
    {
      "element type": "Assignment expression",
      "id": 9,
      "operation type": "="
    },
    {
      "element type": "Instance variable",
      "id": 10,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 11,
      "text": "@root.set_root"
    },
    {
      "element type": "If mod statement",
      "id": 12
    },
    {
      "element type": "Global variable",
      "id": 13,
      "text": "$DEBUG",
      "variable type": "GLOBAL_VARIABLE"
    },
    {
      "element type": "Reference",
      "id": 14,
      "text": "@root.check_height"
    },
    {
      "element type": "Instance variable",
      "id": 15,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 16,
      "text": "@root.check_height"
    },
    {
      "element type": "Compound statement",
      "id": 17,
      "text": "@root = @root.insert(key, value)\n    @root.set_root\n    @root.check_height if $DEBUG"
    },
    {
      "element type": "Body statement",
      "id": 18
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [
        14,
        17
      ]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": []
    }
  ],
  "holder": "[]="
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 2,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "root.retrieve"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 4,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 5,
      "text": "root.retrieve(key)"
    },
    {
      "element type": "Constant",
      "id": 6,
      "text": "Node"
    },
    {
      "element type": "Colon reference",
      "id": 7,
      "text": "Node::UNDEFINED"
    },
    {
      "element type": "Binary expression",
      "id": 8,
      "text": "root.retrieve(key) != Node::UNDEFINED",
      "expression type": "TrueClass or FalseClass",
      "operation type": "!="
    },
    {
      "element type": "Compound statement",
      "id": 9,
      "text": "root.retrieve(key) != Node::UNDEFINED"
    },
    {
      "element type": "Body statement",
      "id": 10
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": []
    }
  ],
  "holder": "key?"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@root.retrieve"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 4,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 5,
      "text": "@root.retrieve(key)"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 6,
      "text": "value"
    },
    {
      "element type": "Assignment expression",
      "id": 7,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 8
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 9,
      "text": "value"
    },
    {
      "element type": "Constant",
      "id": 10,
      "text": "Node"
    },
    {
      "element type": "Colon reference",
      "id": 11,
      "text": "Node::UNDEFINED"
    },
    {
      "element type": "Binary expression",
      "id": 12,
      "text": "value == Node::UNDEFINED",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Compound statement",
      "id": 13,
      "text": "default_value"
    },
    {
      "element type": "Identifier default_value",
      "reference": "default_value",
      "kind": "unknown",
      "id": 14,
      "text": "default_value"
    },
    {
      "element type": "Else block",
      "id": 15
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 16,
      "text": "value"
    },
    {
      "element type": "Compound statement",
      "id": 17,
      "text": "value"
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "value = @root.retrieve(key)\n    if value == Node::UNDEFINED\n      default_value\n    else\n      value\n    end"
    },
    {
      "element type": "Body statement",
      "id": 19
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [
        13,
        15
      ]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [18]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": []
    }
  ],
  "holder": "[]"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Assignment expression",
      "id": 2,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 3,
      "text": "deleted"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@root"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 5,
      "text": "rebalance"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 7,
      "text": "@root.delete"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 8,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 9,
      "text": "@root.delete(key)"
    },
    {
      "element type": "Unless statement",
      "id": 10
    },
    {
      "element type": "Fid",
      "id": 11,
      "text": "empty?"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "@root.set_root\n      @root.check_height if $DEBUG"
    },
    {
      "element type": "Instance variable",
      "id": 13,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 14,
      "text": "@root.set_root"
    },
    {
      "element type": "If mod statement",
      "id": 15
    },
    {
      "element type": "Global variable",
      "id": 16,
      "text": "$DEBUG",
      "variable type": "GLOBAL_VARIABLE"
    },
    {
      "element type": "Reference",
      "id": 17,
      "text": "@root.check_height"
    },
    {
      "element type": "Instance variable",
      "id": 18,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 19,
      "text": "@root.check_height"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 20,
      "text": "deleted"
    },
    {
      "element type": "Reference",
      "id": 21,
      "text": "deleted.value"
    },
    {
      "element type": "Compound statement",
      "id": 22,
      "text": "deleted, @root, rebalance = @root.delete(key)\n    unless empty?\n      @root.set_root\n      @root.check_height if $DEBUG\n    end\n    deleted.value"
    },
    {
      "element type": "Body statement",
      "id": 23
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [
        12,
        20
      ]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [
        17,
        20
      ]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": []
    }
  ],
  "holder": "delete"
}



{
  "nodes description": [
    {
      "element type": "String literal",
      "id": 1,
      "text": "''",
      "value": ""
    },
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "io"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 3,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "root.dump_tree"
    },
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "local variable",
      "id": 5,
      "text": "io"
    },
    {
      "element type": "Call",
      "id": 6,
      "text": "root.dump_tree(io)"
    },
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "local variable",
      "id": 7,
      "text": "io"
    },
    {
      "element type": "Global variable",
      "id": 8,
      "text": "$/",
      "variable type": "GLOBAL_VARIABLE"
    },
    {
      "element type": "Binary expression",
      "id": 9,
      "text": "io << $/",
      "expression type": "Integer",
      "operation type": "<<"
    },
    {
      "element type": "Identifier io",
      "reference": "io",
      "kind": "local variable",
      "id": 10,
      "text": "io"
    },
    {
      "element type": "Compound statement",
      "id": 11,
      "text": "root.dump_tree(io)\n    io << $/\n    io"
    },
    {
      "element type": "Body statement",
      "id": 12
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": []
    }
  ],
  "holder": "dump_tree"
}



{
  "nodes description": [
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 1,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 2,
      "text": "root.dump_sexp"
    },
    {
      "element type": "String literal",
      "id": 5,
      "text": "''",
      "value": ""
    },
    {
      "element type": "Boolean binary expression",
      "id": 6,
      "text": "root.dump_sexp || ''"
    },
    {
      "element type": "Compound statement",
      "id": 7,
      "text": "root.dump_sexp || ''"
    },
    {
      "element type": "Body statement",
      "id": 8
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [
        3,
        4
      ]
    },
    {
      "from": 3,
      "to": [7]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": []
    }
  ],
  "holder": "dump_sexp"
}



{
  "nodes description": [
    {
      "element type": "Assoc list",
      "id": 1
    },
    {
      "element type": "Call",
      "id": 2,
      "text": "inject({})"
    },
    {
      "element type": "Identifier r",
      "reference": "r",
      "kind": "block parameter declaration",
      "id": 3,
      "text": "r"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "block parameter declaration",
      "id": 4,
      "text": "k"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "block parameter declaration",
      "id": 5,
      "text": "v"
    },
    {
      "element type": "Identifier v",
      "reference": "v",
      "kind": "local variable",
      "id": 6,
      "text": "v"
    },
    {
      "element type": "Identifier r",
      "reference": "r",
      "kind": "local variable",
      "id": 7,
      "text": "r"
    },
    {
      "element type": "Identifier k",
      "reference": "k",
      "kind": "local variable",
      "id": 8,
      "text": "k"
    },
    {
      "element type": "Array indexing",
      "id": 9
    },
    {
      "element type": "Assignment expression",
      "id": 10,
      "operation type": "="
    },
    {
      "element type": "Identifier r",
      "reference": "r",
      "kind": "local variable",
      "id": 11,
      "text": "r"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "r[k] = v; r"
    },
    {
      "element type": "Code block",
      "id": 13
    },
    {
      "element type": "Block call",
      "id": 14
    },
    {
      "element type": "Compound statement",
      "id": 15,
      "text": "inject({}) { |r, (k, v)| r[k] = v; r }"
    },
    {
      "element type": "Body statement",
      "id": 16
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [
        3,
        14
      ]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [
        14,
        3
      ]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": []
    }
  ],
  "holder": "to_hash"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@default"
    },
    {
      "element type": "Constant",
      "id": 3,
      "text": "DEFAULT"
    },
    {
      "element type": "Binary expression",
      "id": 4,
      "text": "@default != DEFAULT",
      "expression type": "TrueClass or FalseClass",
      "operation type": "!="
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "@default"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@default"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@default_proc"
    },
    {
      "element type": "Compound statement",
      "id": 8,
      "text": "@default"
    },
    {
      "element type": "Instance variable",
      "id": 9,
      "text": "@default_proc"
    },
    {
      "element type": "Reference",
      "id": 10,
      "text": "@default_proc.call"
    },
    {
      "element type": "Compound statement",
      "id": 11,
      "text": "@default_proc.call"
    },
    {
      "element type": "Else block",
      "id": 12
    },
    {
      "element type": "Pseudo constant",
      "id": 13,
      "text": "nil"
    },
    {
      "element type": "Compound statement",
      "id": 14,
      "text": "nil"
    },
    {
      "element type": "Compound statement",
      "id": 15,
      "text": "if @default != DEFAULT\n      @default\n    elsif @default_proc\n      @default_proc.call\n    else\n      nil\n    end"
    },
    {
      "element type": "Body statement",
      "id": 16
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [
        5,
        7
      ]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [15]
    },
    {
      "from": 7,
      "to": [
        8,
        12
      ]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [15]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": []
    }
  ],
  "holder": "default_value"
}



{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "ConcurrentRedBlackTree"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "RedBlackTree"
    },
    {
      "element type": "Constant",
      "id": 3,
      "text": "Node"
    },
    {
      "element type": "Alias statement",
      "new name": "insert",
      "old name": "[]=",
      "id": 4
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "class ConcurrentNode < Node\n    # direction: ~LEFT == RIGHT, ~RIGHT == LEFT\n    LEFT = -1\n    RIGHT = 0\n\n    # @Overrides\n    def insert(key, value)\n      case key <=> @key\n      when -1\n        dir = LEFT\n      when 0\n        node = new_value(value)\n      when 1\n        dir = RIGHT\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      if dir\n        target = child(dir).insert(key, value)\n        node = new_child(dir, target)\n        if black? and child(~dir).black? and target.red? and !target.children_color?(:BLACK)\n          node = node.rebalance_for_insert(dir)\n        end\n      end\n      node.pullup_red\n    end\n\n    # @Overrides\n    def retrieve(key)\n      case key <=> @key\n      when -1\n        @left.retrieve(key)\n      when 0\n        @value\n      when 1\n        @right.retrieve(key)\n      else\n        nil\n      end\n    end\n\n    # @Overrides\n    def delete(key)\n      case key <=> @key\n      when -1\n        dir = LEFT\n      when 0\n        deleted = self\n        node, rebalance = delete_node\n      when 1\n        dir = RIGHT\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      if dir\n        deleted, target, rebalance = child(dir).delete(key)\n        node = new_child(dir, target)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(dir)\n        end\n      end\n      [deleted, node, rebalance]\n    end\n\n    protected\n\n    def new_children(dir, node, other, color = @color)\n      dir == LEFT ?\n          ConcurrentNode.new(@key, @value, node, other, color) :\n          ConcurrentNode.new(@key, @value, other, node, color)\n    end\n\n    def new_child(dir, node, color = @color)\n      dir == LEFT ?\n          ConcurrentNode.new(@key, @value, node, @right, color) :\n          ConcurrentNode.new(@key, @value, @left, node, color)\n    end\n\n    def new_color(color)\n      ConcurrentNode.new(@key, @value, @left, @right, color)\n    end\n\n    def new_value(value)\n      ConcurrentNode.new(@key, value, @left, @right, @color)\n    end\n\n    def child(dir)\n      dir == LEFT ? @left : @right\n    end\n\n    # @Overrides\n    def delete_min\n      if @left.empty?\n        [self, *delete_node]\n      else\n        deleted, left, rebalance = @left.delete_min\n        node = new_child(LEFT, left)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(LEFT)\n        end\n        [deleted, node, rebalance]\n      end\n    end\n\n    # rebalance when the left/right sub-tree is 1 level lower than the right/left\n    def rebalance_for_delete(dir)\n      target = child(~dir)\n      rebalance = false\n      if black?\n        if target.black?\n          if target.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            node = new_child(~dir, target.new_color(:RED))\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            node = balanced_rotate(dir)\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          node = rotate(dir)\n          # try to rebalance in sub-tree\n          target, rebalance = node.child(dir).rebalance_for_delete(dir)\n          raise 'should not happen' if rebalance\n          node = node.new_children(dir, target, node.child(~dir))\n        end\n      else # red\n        if target.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          node = new_child(~dir, target.new_color(@color), target.color)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          node = balanced_rotate(dir)\n        end\n      end\n      [node, rebalance]\n    end\n\n    # move 1 black from the right/left to the left/right by single/double rotation\n    def balanced_rotate(dir)\n      target = child(~dir)\n      if target.child(dir).red? and target.child(~dir).black?\n        node = new_child(~dir, target.rotate(~dir))\n      else\n        node = self\n      end\n      node = node.rotate(dir)\n      node.new_children(dir, node.child(dir).new_color(:BLACK), node.child(~dir).new_color(:BLACK))\n    end\n\n    # Right single rotation\n    # (b a (D c E)) where D and E are RED --> (d (B a c) E)\n    #\n    #   b              d\n    #  / \\            / \\\n    # a   D    ->    B   E\n    #    / \\        / \\\n    #   c   E      a   c\n    #\n    # Left single rotation\n    # (d (B A c) e) where A and B are RED --> (b A (D c e))\n    #\n    #     d          b\n    #    / \\        / \\\n    #   B   e  ->  A   D\n    #  / \\            / \\\n    # A   c          c   e\n    #\n    def rotate(dir)\n      new_root = child(~dir)\n      node = new_child(~dir, new_root.child(dir), new_root.color)\n      new_root.new_children(dir, node, new_root.child(~dir), @color)\n    end\n\n    # Pull up red nodes\n    # (b (A C)) where A and C are RED --> (B (a c))\n    #\n    #   b          B\n    #  / \\   ->   / \\\n    # A   C      a   c\n    #\n    # @Overrides\n    def pullup_red\n      if black? and @left.red? and @right.red?\n        new_children(LEFT, @left.new_color(:BLACK), @right.new_color(:BLACK), :RED)\n      else\n        self\n      end\n    end\n\n    # rebalance when the left/right sub-tree is 1 level higher than the right/left\n    # move 1 black from the left to the right by single/double rotation\n    #\n    # precondition: self is black and @left/@right is red\n    def rebalance_for_insert(dir)\n      node = self\n      if child(dir).child(~dir).red?\n        node = new_child(dir, child(dir).rotate(dir))\n      end\n      node.rotate(~dir)\n    end\n\n    private\n\n    # @Overrides\n    def delete_node\n      rebalance = false\n      if @left.empty? and @right.empty?\n        # just remove this node and ask rebalance to the parent\n        new_node = EMPTY_CONCURRENT\n        if black?\n          rebalance = true\n        end\n      elsif @left.empty? or @right.empty?\n        # pick the single children\n        new_node = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_node.red?\n          new_node = new_node.new_color(@color)\n        else\n          # just remove the red node\n        end\n      else\n        # pick the minimum node from the right sub-tree and replace self with it\n        deleted, right, rebalance = @right.delete_min\n        new_node = deleted.new_children(LEFT, @left, right, @color)\n        if rebalance\n          new_node, rebalance = new_node.rebalance_for_delete(RIGHT)\n        end\n      end\n      [new_node, rebalance]\n    end\n\n    class EmptyConcurrentNode < EmptyNode\n      # @Overrides\n      def insert(key, value)\n        ConcurrentNode.new(key, value, self, self)\n      end\n    end\n    EMPTY_CONCURRENT = ConcurrentNode::EmptyConcurrentNode.new.freeze\n  end\n\n  def initialize(default = DEFAULT, &block)\n    super\n    @root = Atomic.new(ConcurrentNode::EMPTY_CONCURRENT)\n  end\n\n  def root\n    @root.get\n  end\n\n  def empty?\n    root == ConcurrentNode::EMPTY_CONCURRENT\n  end\n\n  def clear\n    @root.set(ConcurrentNode::EMPTY_CONCURRENT)\n  end\n\n  def []=(key, value)\n    @root.update { |root|\n      root = root.insert(key, value)\n      root.set_root\n      root.check_height if $DEBUG\n      root\n    }\n  end\n  alias insert []=\n\n  def [](key)\n    value = @root.get.retrieve(key)\n    if value == Node::UNDEFINED\n      default_value\n    else\n      value\n    end\n  end\n\n  def delete(key)\n    deleted = nil\n    @root.update { |root|\n      deleted, root, rebalance = root.delete(key)\n      unless root == ConcurrentNode::EMPTY_CONCURRENT\n        root.set_root\n        root.check_height if $DEBUG\n      end\n      root\n    }\n    deleted.value\n  end"
    },
    {
      "element type": "Body statement",
      "id": 6
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": []
    }
  ],
  "holder": "ConcurrentRedBlackTree"
}


{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "Node"
    },
    {
      "element type": "Integer constant",
      "id": 3,
      "text": "-1"
    },
    {
      "element type": "Constant",
      "id": 4,
      "text": "LEFT"
    },
    {
      "element type": "Assignment expression",
      "id": 5,
      "operation type": "="
    },
    {
      "element type": "Integer constant",
      "id": 6,
      "text": "0"
    },
    {
      "element type": "Constant",
      "id": 7,
      "text": "RIGHT"
    },
    {
      "element type": "Assignment expression",
      "id": 8,
      "operation type": "="
    },
    {
      "element type": "Identifier protected",
      "reference": "protected",
      "kind": "unknown",
      "id": 9,
      "text": "protected"
    },
    {
      "element type": "Identifier private",
      "reference": "private",
      "kind": "unknown",
      "id": 10,
      "text": "private"
    },
    {
      "element type": "Constant",
      "id": 11,
      "text": "EmptyNode"
    },
    {
      "element type": "Constant",
      "id": 12,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Colon reference",
      "id": 13,
      "text": "ConcurrentNode::EmptyConcurrentNode"
    },
    {
      "element type": "Reference",
      "id": 14,
      "text": "ConcurrentNode::EmptyConcurrentNode.new"
    },
    {
      "element type": "Reference",
      "id": 15,
      "text": "ConcurrentNode::EmptyConcurrentNode.new.freeze"
    },
    {
      "element type": "Constant",
      "id": 16,
      "text": "EMPTY_CONCURRENT"
    },
    {
      "element type": "Assignment expression",
      "id": 17,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "LEFT = -1\n    RIGHT = 0\n\n    # @Overrides\n    def insert(key, value)\n      case key <=> @key\n      when -1\n        dir = LEFT\n      when 0\n        node = new_value(value)\n      when 1\n        dir = RIGHT\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      if dir\n        target = child(dir).insert(key, value)\n        node = new_child(dir, target)\n        if black? and child(~dir).black? and target.red? and !target.children_color?(:BLACK)\n          node = node.rebalance_for_insert(dir)\n        end\n      end\n      node.pullup_red\n    end\n\n    # @Overrides\n    def retrieve(key)\n      case key <=> @key\n      when -1\n        @left.retrieve(key)\n      when 0\n        @value\n      when 1\n        @right.retrieve(key)\n      else\n        nil\n      end\n    end\n\n    # @Overrides\n    def delete(key)\n      case key <=> @key\n      when -1\n        dir = LEFT\n      when 0\n        deleted = self\n        node, rebalance = delete_node\n      when 1\n        dir = RIGHT\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      if dir\n        deleted, target, rebalance = child(dir).delete(key)\n        node = new_child(dir, target)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(dir)\n        end\n      end\n      [deleted, node, rebalance]\n    end\n\n    protected\n\n    def new_children(dir, node, other, color = @color)\n      dir == LEFT ?\n          ConcurrentNode.new(@key, @value, node, other, color) :\n          ConcurrentNode.new(@key, @value, other, node, color)\n    end\n\n    def new_child(dir, node, color = @color)\n      dir == LEFT ?\n          ConcurrentNode.new(@key, @value, node, @right, color) :\n          ConcurrentNode.new(@key, @value, @left, node, color)\n    end\n\n    def new_color(color)\n      ConcurrentNode.new(@key, @value, @left, @right, color)\n    end\n\n    def new_value(value)\n      ConcurrentNode.new(@key, value, @left, @right, @color)\n    end\n\n    def child(dir)\n      dir == LEFT ? @left : @right\n    end\n\n    # @Overrides\n    def delete_min\n      if @left.empty?\n        [self, *delete_node]\n      else\n        deleted, left, rebalance = @left.delete_min\n        node = new_child(LEFT, left)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(LEFT)\n        end\n        [deleted, node, rebalance]\n      end\n    end\n\n    # rebalance when the left/right sub-tree is 1 level lower than the right/left\n    def rebalance_for_delete(dir)\n      target = child(~dir)\n      rebalance = false\n      if black?\n        if target.black?\n          if target.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            node = new_child(~dir, target.new_color(:RED))\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            node = balanced_rotate(dir)\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          node = rotate(dir)\n          # try to rebalance in sub-tree\n          target, rebalance = node.child(dir).rebalance_for_delete(dir)\n          raise 'should not happen' if rebalance\n          node = node.new_children(dir, target, node.child(~dir))\n        end\n      else # red\n        if target.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          node = new_child(~dir, target.new_color(@color), target.color)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          node = balanced_rotate(dir)\n        end\n      end\n      [node, rebalance]\n    end\n\n    # move 1 black from the right/left to the left/right by single/double rotation\n    def balanced_rotate(dir)\n      target = child(~dir)\n      if target.child(dir).red? and target.child(~dir).black?\n        node = new_child(~dir, target.rotate(~dir))\n      else\n        node = self\n      end\n      node = node.rotate(dir)\n      node.new_children(dir, node.child(dir).new_color(:BLACK), node.child(~dir).new_color(:BLACK))\n    end\n\n    # Right single rotation\n    # (b a (D c E)) where D and E are RED --> (d (B a c) E)\n    #\n    #   b              d\n    #  / \\            / \\\n    # a   D    ->    B   E\n    #    / \\        / \\\n    #   c   E      a   c\n    #\n    # Left single rotation\n    # (d (B A c) e) where A and B are RED --> (b A (D c e))\n    #\n    #     d          b\n    #    / \\        / \\\n    #   B   e  ->  A   D\n    #  / \\            / \\\n    # A   c          c   e\n    #\n    def rotate(dir)\n      new_root = child(~dir)\n      node = new_child(~dir, new_root.child(dir), new_root.color)\n      new_root.new_children(dir, node, new_root.child(~dir), @color)\n    end\n\n    # Pull up red nodes\n    # (b (A C)) where A and C are RED --> (B (a c))\n    #\n    #   b          B\n    #  / \\   ->   / \\\n    # A   C      a   c\n    #\n    # @Overrides\n    def pullup_red\n      if black? and @left.red? and @right.red?\n        new_children(LEFT, @left.new_color(:BLACK), @right.new_color(:BLACK), :RED)\n      else\n        self\n      end\n    end\n\n    # rebalance when the left/right sub-tree is 1 level higher than the right/left\n    # move 1 black from the left to the right by single/double rotation\n    #\n    # precondition: self is black and @left/@right is red\n    def rebalance_for_insert(dir)\n      node = self\n      if child(dir).child(~dir).red?\n        node = new_child(dir, child(dir).rotate(dir))\n      end\n      node.rotate(~dir)\n    end\n\n    private\n\n    # @Overrides\n    def delete_node\n      rebalance = false\n      if @left.empty? and @right.empty?\n        # just remove this node and ask rebalance to the parent\n        new_node = EMPTY_CONCURRENT\n        if black?\n          rebalance = true\n        end\n      elsif @left.empty? or @right.empty?\n        # pick the single children\n        new_node = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_node.red?\n          new_node = new_node.new_color(@color)\n        else\n          # just remove the red node\n        end\n      else\n        # pick the minimum node from the right sub-tree and replace self with it\n        deleted, right, rebalance = @right.delete_min\n        new_node = deleted.new_children(LEFT, @left, right, @color)\n        if rebalance\n          new_node, rebalance = new_node.rebalance_for_delete(RIGHT)\n        end\n      end\n      [new_node, rebalance]\n    end\n\n    class EmptyConcurrentNode < EmptyNode\n      # @Overrides\n      def insert(key, value)\n        ConcurrentNode.new(key, value, self, self)\n      end\n    end\n    EMPTY_CONCURRENT = ConcurrentNode::EmptyConcurrentNode.new.freeze"
    },
    {
      "element type": "Body statement",
      "id": 19
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": []
    }
  ],
  "holder": "ConcurrentNode"
}


{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "value"
    },
    {
      "element type": "Case statement",
      "id": 3
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 4,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 5,
      "text": "@key"
    },
    {
      "element type": "Binary expression",
      "id": 6,
      "text": "key <=> @key",
      "expression type": "TrueClass or FalseClass",
      "operation type": "<=>"
    },
    {
      "element type": "When case",
      "id": 7
    },
    {
      "element type": "Integer constant",
      "id": 8,
      "text": "-1"
    },
    {
      "element type": "Constant",
      "id": 9,
      "text": "LEFT"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 10,
      "text": "dir"
    },
    {
      "element type": "Assignment expression",
      "id": 11,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "dir = LEFT"
    },
    {
      "element type": "When case",
      "id": 13
    },
    {
      "element type": "Integer constant",
      "id": 14,
      "text": "0"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 15,
      "text": "value"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_value",
      "id": 16,
      "text": "new_value(value)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 17,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 18,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 19,
      "text": "node = new_value(value)"
    },
    {
      "element type": "When case",
      "id": 20
    },
    {
      "element type": "Integer constant",
      "id": 21,
      "text": "1"
    },
    {
      "element type": "Constant",
      "id": 22,
      "text": "RIGHT"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 23,
      "text": "dir"
    },
    {
      "element type": "Assignment expression",
      "id": 24,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 25,
      "text": "dir = RIGHT"
    },
    {
      "element type": "Else block",
      "id": 26
    },
    {
      "element type": "Constant",
      "id": 27,
      "text": "TypeError"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 28,
      "text": "key"
    },
    {
      "element type": "Compound statement",
      "id": 29,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 30,
      "text": "@key"
    },
    {
      "element type": "Compound statement",
      "id": 31,
      "text": "@key"
    },
    {
      "element type": "String literal",
      "id": 32,
      "text": "\"cannot compare #{key} and #{@key} with <=>\"",
      "value": "cannot compare #{key} and #{@key} with <=>"
    },
    {
      "element type": "Call",
      "id": 33,
      "text": "raise TypeError, \"cannot compare #{key} and #{@key} with <=>\""
    },
    {
      "element type": "Compound statement",
      "id": 34,
      "text": "raise TypeError, \"cannot compare #{key} and #{@key} with <=>\""
    },
    {
      "element type": "If statement",
      "id": 35
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 36,
      "text": "dir"
    },
    {
      "element type": "Compound statement",
      "id": 37,
      "text": "target = child(dir).insert(key, value)\n        node = new_child(dir, target)\n        if black? and child(~dir).black? and target.red? and !target.children_color?(:BLACK)\n          node = node.rebalance_for_insert(dir)\n        end"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 38,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 39,
      "text": "child(dir)"
    },
    {
      "element type": "Reference",
      "id": 40,
      "text": "child(dir).insert"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 41,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 42,
      "text": "value"
    },
    {
      "element type": "Call",
      "id": 43,
      "text": "child(dir).insert(key, value)"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 44,
      "text": "target"
    },
    {
      "element type": "Assignment expression",
      "id": 45,
      "operation type": "="
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 46,
      "text": "dir"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 47,
      "text": "target"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_child",
      "id": 48,
      "text": "new_child(dir, target)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 49,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 50,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 51
    },
    {
      "element type": "Fid",
      "id": 52,
      "text": "black?"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 55,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 56,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 57,
      "text": "child(~dir)"
    },
    {
      "element type": "Reference",
      "id": 58,
      "text": "child(~dir).black?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 59,
      "text": "black? and child(~dir).black?"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 62,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 63,
      "text": "target.red?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 64,
      "text": "black? and child(~dir).black? and target.red?"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 67,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 68,
      "text": "target.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 69,
      "text": "target.children_color?(:BLACK)"
    },
    {
      "element type": "Unary expression",
      "id": 70,
      "text": "!target.children_color?(:BLACK)",
      "expression type": "TrueClass or FalseClass",
      "operation": "!"
    },
    {
      "element type": "Boolean binary expression",
      "id": 71,
      "text": "black? and child(~dir).black? and target.red? and !target.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 72,
      "text": "node = node.rebalance_for_insert(dir)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 73,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 74,
      "text": "node.rebalance_for_insert"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 75,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "rebalance_for_insert",
      "id": 76,
      "text": "node.rebalance_for_insert(dir)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 77,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 78,
      "operation type": "="
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 79,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 80,
      "text": "node.pullup_red"
    },
    {
      "element type": "Compound statement",
      "id": 81,
      "text": "case key <=> @key\n      when -1\n        dir = LEFT\n      when 0\n        node = new_value(value)\n      when 1\n        dir = RIGHT\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      if dir\n        target = child(dir).insert(key, value)\n        node = new_child(dir, target)\n        if black? and child(~dir).black? and target.red? and !target.children_color?(:BLACK)\n          node = node.rebalance_for_insert(dir)\n        end\n      end\n      node.pullup_red"
    },
    {
      "element type": "Body statement",
      "id": 82
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [
        7,
        13,
        20,
        26
      ]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [35]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [35]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [35]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": []
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [
        37,
        79
      ]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [43]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": [48]
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [
        53,
        54
      ]
    },
    {
      "from": 53,
      "to": [55]
    },
    {
      "from": 54,
      "to": [79]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [
        60,
        61
      ]
    },
    {
      "from": 60,
      "to": [62]
    },
    {
      "from": 61,
      "to": [79]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [
        65,
        66
      ]
    },
    {
      "from": 65,
      "to": [67]
    },
    {
      "from": 66,
      "to": [79]
    },
    {
      "from": 67,
      "to": [68]
    },
    {
      "from": 68,
      "to": [69]
    },
    {
      "from": 69,
      "to": [70]
    },
    {
      "from": 70,
      "to": [71]
    },
    {
      "from": 71,
      "to": [
        72,
        79
      ]
    },
    {
      "from": 72,
      "to": [73]
    },
    {
      "from": 73,
      "to": [74]
    },
    {
      "from": 74,
      "to": [75]
    },
    {
      "from": 75,
      "to": [76]
    },
    {
      "from": 76,
      "to": [77]
    },
    {
      "from": 77,
      "to": [78]
    },
    {
      "from": 78,
      "to": [79]
    },
    {
      "from": 79,
      "to": [80]
    },
    {
      "from": 80,
      "to": [81]
    },
    {
      "from": 81,
      "to": [82]
    },
    {
      "from": 82,
      "to": [83]
    },
    {
      "from": 83,
      "to": []
    }
  ],
  "holder": "insert"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Case statement",
      "id": 2
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 3,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@key"
    },
    {
      "element type": "Binary expression",
      "id": 5,
      "text": "key <=> @key",
      "expression type": "TrueClass or FalseClass",
      "operation type": "<=>"
    },
    {
      "element type": "When case",
      "id": 6
    },
    {
      "element type": "Integer constant",
      "id": 7,
      "text": "-1"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 9,
      "text": "@left.retrieve"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 10,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 11,
      "text": "@left.retrieve(key)"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "@left.retrieve(key)"
    },
    {
      "element type": "When case",
      "id": 13
    },
    {
      "element type": "Integer constant",
      "id": 14,
      "text": "0"
    },
    {
      "element type": "Instance variable",
      "id": 15,
      "text": "@value"
    },
    {
      "element type": "Compound statement",
      "id": 16,
      "text": "@value"
    },
    {
      "element type": "When case",
      "id": 17
    },
    {
      "element type": "Integer constant",
      "id": 18,
      "text": "1"
    },
    {
      "element type": "Instance variable",
      "id": 19,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 20,
      "text": "@right.retrieve"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 21,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 22,
      "text": "@right.retrieve(key)"
    },
    {
      "element type": "Compound statement",
      "id": 23,
      "text": "@right.retrieve(key)"
    },
    {
      "element type": "Else block",
      "id": 24
    },
    {
      "element type": "Pseudo constant",
      "id": 25,
      "text": "nil"
    },
    {
      "element type": "Compound statement",
      "id": 26,
      "text": "nil"
    },
    {
      "element type": "Compound statement",
      "id": 27,
      "text": "case key <=> @key\n      when -1\n        @left.retrieve(key)\n      when 0\n        @value\n      when 1\n        @right.retrieve(key)\n      else\n        nil\n      end"
    },
    {
      "element type": "Body statement",
      "id": 28
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [
        6,
        13,
        17,
        24
      ]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [27]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [27]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [27]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": []
    }
  ],
  "holder": "retrieve"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Case statement",
      "id": 2
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 3,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@key"
    },
    {
      "element type": "Binary expression",
      "id": 5,
      "text": "key <=> @key",
      "expression type": "TrueClass or FalseClass",
      "operation type": "<=>"
    },
    {
      "element type": "When case",
      "id": 6
    },
    {
      "element type": "Integer constant",
      "id": 7,
      "text": "-1"
    },
    {
      "element type": "Constant",
      "id": 8,
      "text": "LEFT"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 9,
      "text": "dir"
    },
    {
      "element type": "Assignment expression",
      "id": 10,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 11,
      "text": "dir = LEFT"
    },
    {
      "element type": "When case",
      "id": 12
    },
    {
      "element type": "Integer constant",
      "id": 13,
      "text": "0"
    },
    {
      "element type": "Pseudo constant",
      "id": 14,
      "text": "self"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 15,
      "text": "deleted"
    },
    {
      "element type": "Assignment expression",
      "id": 16,
      "operation type": "="
    },
    {
      "element type": "Assignment expression",
      "id": 17,
      "operation type": "="
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 18,
      "text": "node"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 19,
      "text": "rebalance"
    },
    {
      "element type": "Identifier delete_node",
      "reference": "delete_node",
      "kind": "unknown",
      "id": 20,
      "text": "delete_node"
    },
    {
      "element type": "Compound statement",
      "id": 21,
      "text": "deleted = self\n        node, rebalance = delete_node"
    },
    {
      "element type": "When case",
      "id": 22
    },
    {
      "element type": "Integer constant",
      "id": 23,
      "text": "1"
    },
    {
      "element type": "Constant",
      "id": 24,
      "text": "RIGHT"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 25,
      "text": "dir"
    },
    {
      "element type": "Assignment expression",
      "id": 26,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 27,
      "text": "dir = RIGHT"
    },
    {
      "element type": "Else block",
      "id": 28
    },
    {
      "element type": "Constant",
      "id": 29,
      "text": "TypeError"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 30,
      "text": "key"
    },
    {
      "element type": "Compound statement",
      "id": 31,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 32,
      "text": "@key"
    },
    {
      "element type": "Compound statement",
      "id": 33,
      "text": "@key"
    },
    {
      "element type": "String literal",
      "id": 34,
      "text": "\"cannot compare #{key} and #{@key} with <=>\"",
      "value": "cannot compare #{key} and #{@key} with <=>"
    },
    {
      "element type": "Call",
      "id": 35,
      "text": "raise TypeError, \"cannot compare #{key} and #{@key} with <=>\""
    },
    {
      "element type": "Compound statement",
      "id": 36,
      "text": "raise TypeError, \"cannot compare #{key} and #{@key} with <=>\""
    },
    {
      "element type": "If statement",
      "id": 37
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 38,
      "text": "dir"
    },
    {
      "element type": "Compound statement",
      "id": 39,
      "text": "deleted, target, rebalance = child(dir).delete(key)\n        node = new_child(dir, target)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(dir)\n        end"
    },
    {
      "element type": "Assignment expression",
      "id": 40,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 41,
      "text": "deleted"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 42,
      "text": "target"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 43,
      "text": "rebalance"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 44,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 45,
      "text": "child(dir)"
    },
    {
      "element type": "Reference",
      "id": 46,
      "text": "child(dir).delete"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 47,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 48,
      "text": "child(dir).delete(key)"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 49,
      "text": "dir"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 50,
      "text": "target"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_child",
      "id": 51,
      "text": "new_child(dir, target)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 52,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 53,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 54
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 55,
      "text": "rebalance"
    },
    {
      "element type": "Compound statement",
      "id": 56,
      "text": "node, rebalance = node.rebalance_for_delete(dir)"
    },
    {
      "element type": "Assignment expression",
      "id": 57,
      "operation type": "="
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 58,
      "text": "node"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 59,
      "text": "rebalance"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 60,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 61,
      "text": "node.rebalance_for_delete"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 62,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "rebalance_for_delete",
      "id": 63,
      "text": "node.rebalance_for_delete(dir)"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 64,
      "text": "deleted"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 65,
      "text": "node"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 66,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 67,
      "text": "[deleted, node, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 68,
      "text": "case key <=> @key\n      when -1\n        dir = LEFT\n      when 0\n        deleted = self\n        node, rebalance = delete_node\n      when 1\n        dir = RIGHT\n      else\n        raise TypeError, \"cannot compare #{key} and #{@key} with <=>\"\n      end\n      if dir\n        deleted, target, rebalance = child(dir).delete(key)\n        node = new_child(dir, target)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(dir)\n        end\n      end\n      [deleted, node, rebalance]"
    },
    {
      "element type": "Body statement",
      "id": 69
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [
        6,
        12,
        22,
        28
      ]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [37]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [37]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [37]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": []
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [
        39,
        64
      ]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [43]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": [48]
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [53]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [55]
    },
    {
      "from": 55,
      "to": [
        56,
        64
      ]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [65]
    },
    {
      "from": 65,
      "to": [66]
    },
    {
      "from": 66,
      "to": [67]
    },
    {
      "from": 67,
      "to": [68]
    },
    {
      "from": 68,
      "to": [69]
    },
    {
      "from": 69,
      "to": [70]
    },
    {
      "from": 70,
      "to": []
    }
  ],
  "holder": "delete"
}



{
  "nodes description": [
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "dir"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "node"
    },
    {
      "element type": "Identifier other",
      "reference": "other",
      "kind": "method parameter declaration",
      "id": 3,
      "text": "other"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@color"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "method parameter declaration",
      "id": 5,
      "text": "color"
    },
    {
      "element type": "Ternary expression",
      "id": 6
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 7,
      "text": "dir"
    },
    {
      "element type": "Constant",
      "id": 8,
      "text": "LEFT"
    },
    {
      "element type": "Binary expression",
      "id": 9,
      "text": "dir == LEFT",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Call",
      "id": 10,
      "text": "ConcurrentNode.new(@key, @value, node, other, color)"
    },
    {
      "element type": "Constant",
      "id": 11,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Reference",
      "id": 12,
      "text": "ConcurrentNode.new"
    },
    {
      "element type": "Instance variable",
      "id": 13,
      "text": "@key"
    },
    {
      "element type": "Instance variable",
      "id": 14,
      "text": "@value"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 15,
      "text": "node"
    },
    {
      "element type": "Identifier other",
      "reference": "other",
      "kind": "local variable",
      "id": 16,
      "text": "other"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "local variable",
      "id": 17,
      "text": "color"
    },
    {
      "element type": "Call",
      "id": 18,
      "text": "ConcurrentNode.new(@key, @value, node, other, color)"
    },
    {
      "element type": "Call",
      "id": 19,
      "text": "ConcurrentNode.new(@key, @value, other, node, color)"
    },
    {
      "element type": "Constant",
      "id": 20,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Reference",
      "id": 21,
      "text": "ConcurrentNode.new"
    },
    {
      "element type": "Instance variable",
      "id": 22,
      "text": "@key"
    },
    {
      "element type": "Instance variable",
      "id": 23,
      "text": "@value"
    },
    {
      "element type": "Identifier other",
      "reference": "other",
      "kind": "local variable",
      "id": 24,
      "text": "other"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 25,
      "text": "node"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "local variable",
      "id": 26,
      "text": "color"
    },
    {
      "element type": "Call",
      "id": 27,
      "text": "ConcurrentNode.new(@key, @value, other, node, color)"
    },
    {
      "element type": "Compound statement",
      "id": 28,
      "text": "dir == LEFT ?\n          ConcurrentNode.new(@key, @value, node, other, color) :\n          ConcurrentNode.new(@key, @value, other, node, color)"
    },
    {
      "element type": "Body statement",
      "id": 29
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [
        10,
        19
      ]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [28]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": []
    }
  ],
  "holder": "new_children"
}



{
  "nodes description": [
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "dir"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "node"
    },
    {
      "element type": "Instance variable",
      "id": 3,
      "text": "@color"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "method parameter declaration",
      "id": 4,
      "text": "color"
    },
    {
      "element type": "Ternary expression",
      "id": 5
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 6,
      "text": "dir"
    },
    {
      "element type": "Constant",
      "id": 7,
      "text": "LEFT"
    },
    {
      "element type": "Binary expression",
      "id": 8,
      "text": "dir == LEFT",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Call",
      "id": 9,
      "text": "ConcurrentNode.new(@key, @value, node, @right, color)"
    },
    {
      "element type": "Constant",
      "id": 10,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Reference",
      "id": 11,
      "text": "ConcurrentNode.new"
    },
    {
      "element type": "Instance variable",
      "id": 12,
      "text": "@key"
    },
    {
      "element type": "Instance variable",
      "id": 13,
      "text": "@value"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 14,
      "text": "node"
    },
    {
      "element type": "Instance variable",
      "id": 15,
      "text": "@right"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "local variable",
      "id": 16,
      "text": "color"
    },
    {
      "element type": "Call",
      "id": 17,
      "text": "ConcurrentNode.new(@key, @value, node, @right, color)"
    },
    {
      "element type": "Call",
      "id": 18,
      "text": "ConcurrentNode.new(@key, @value, @left, node, color)"
    },
    {
      "element type": "Constant",
      "id": 19,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Reference",
      "id": 20,
      "text": "ConcurrentNode.new"
    },
    {
      "element type": "Instance variable",
      "id": 21,
      "text": "@key"
    },
    {
      "element type": "Instance variable",
      "id": 22,
      "text": "@value"
    },
    {
      "element type": "Instance variable",
      "id": 23,
      "text": "@left"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 24,
      "text": "node"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "local variable",
      "id": 25,
      "text": "color"
    },
    {
      "element type": "Call",
      "id": 26,
      "text": "ConcurrentNode.new(@key, @value, @left, node, color)"
    },
    {
      "element type": "Compound statement",
      "id": 27,
      "text": "dir == LEFT ?\n          ConcurrentNode.new(@key, @value, node, @right, color) :\n          ConcurrentNode.new(@key, @value, @left, node, color)"
    },
    {
      "element type": "Body statement",
      "id": 28
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [
        9,
        18
      ]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [27]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": []
    }
  ],
  "holder": "new_child"
}



{
  "nodes description": [
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "color"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "ConcurrentNode.new"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@key"
    },
    {
      "element type": "Instance variable",
      "id": 5,
      "text": "@value"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@left"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@right"
    },
    {
      "element type": "Identifier color",
      "reference": "color",
      "kind": "local variable",
      "id": 8,
      "text": "color"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "id": 9,
      "text": "ConcurrentNode.new(@key, @value, @left, @right, color)"
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "ConcurrentNode.new(@key, @value, @left, @right, color)"
    },
    {
      "element type": "Body statement",
      "id": 11
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": []
    }
  ],
  "holder": "new_color"
}



{
  "nodes description": [
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "value"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "ConcurrentNode.new"
    },
    {
      "element type": "Instance variable",
      "id": 4,
      "text": "@key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 5,
      "text": "value"
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@left"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@right"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@color"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "id": 9,
      "text": "ConcurrentNode.new(@key, value, @left, @right, @color)"
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "ConcurrentNode.new(@key, value, @left, @right, @color)"
    },
    {
      "element type": "Body statement",
      "id": 11
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": []
    }
  ],
  "holder": "new_value"
}



{
  "nodes description": [
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "dir"
    },
    {
      "element type": "Ternary expression",
      "id": 2
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 3,
      "text": "dir"
    },
    {
      "element type": "Constant",
      "id": 4,
      "text": "LEFT"
    },
    {
      "element type": "Binary expression",
      "id": 5,
      "text": "dir == LEFT",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Instance variable",
      "id": 6,
      "text": "@left"
    },
    {
      "element type": "Instance variable",
      "id": 7,
      "text": "@left"
    },
    {
      "element type": "Instance variable",
      "id": 8,
      "text": "@right"
    },
    {
      "element type": "Instance variable",
      "id": 9,
      "text": "@right"
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "dir == LEFT ? @left : @right"
    },
    {
      "element type": "Body statement",
      "id": 11
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [
        6,
        8
      ]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [10]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": []
    }
  ],
  "holder": "child"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@left.empty?"
    },
    {
      "element type": "Compound statement",
      "id": 4,
      "text": "[self, *delete_node]"
    },
    {
      "element type": "Pseudo constant",
      "id": 5,
      "text": "self"
    },
    {
      "element type": "Identifier delete_node",
      "reference": "delete_node",
      "kind": "unknown",
      "id": 6,
      "text": "delete_node"
    },
    {
      "element type": "Array",
      "id": 7,
      "text": "[self, *delete_node]"
    },
    {
      "element type": "Else block",
      "id": 8
    },
    {
      "element type": "Assignment expression",
      "id": 9,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 10,
      "text": "deleted"
    },
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "local variable",
      "id": 11,
      "text": "left"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 12,
      "text": "rebalance"
    },
    {
      "element type": "Instance variable",
      "id": 13,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 14,
      "text": "@left.delete_min"
    },
    {
      "element type": "Constant",
      "id": 15,
      "text": "LEFT"
    },
    {
      "element type": "Identifier left",
      "reference": "left",
      "kind": "local variable",
      "id": 16,
      "text": "left"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_child",
      "id": 17,
      "text": "new_child(LEFT, left)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 18,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 19,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 20
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 21,
      "text": "rebalance"
    },
    {
      "element type": "Compound statement",
      "id": 22,
      "text": "node, rebalance = node.rebalance_for_delete(LEFT)"
    },
    {
      "element type": "Assignment expression",
      "id": 23,
      "operation type": "="
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 24,
      "text": "node"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 25,
      "text": "rebalance"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 26,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 27,
      "text": "node.rebalance_for_delete"
    },
    {
      "element type": "Constant",
      "id": 28,
      "text": "LEFT"
    },
    {
      "element type": "Call",
      "callee": "rebalance_for_delete",
      "id": 29,
      "text": "node.rebalance_for_delete(LEFT)"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 30,
      "text": "deleted"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 31,
      "text": "node"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 32,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 33,
      "text": "[deleted, node, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 34,
      "text": "deleted, left, rebalance = @left.delete_min\n        node = new_child(LEFT, left)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(LEFT)\n        end\n        [deleted, node, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 35,
      "text": "if @left.empty?\n        [self, *delete_node]\n      else\n        deleted, left, rebalance = @left.delete_min\n        node = new_child(LEFT, left)\n        if rebalance\n          node, rebalance = node.rebalance_for_delete(LEFT)\n        end\n        [deleted, node, rebalance]\n      end"
    },
    {
      "element type": "Body statement",
      "id": 36
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [
        4,
        8
      ]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [35]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [
        22,
        30
      ]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": []
    }
  ],
  "holder": "delete_min"
}



{
  "nodes description": [
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "dir"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 2,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 3,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 4,
      "text": "child(~dir)"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 5,
      "text": "target"
    },
    {
      "element type": "Assignment expression",
      "id": 6,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 7,
      "text": "false"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 8,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 9,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 10
    },
    {
      "element type": "Fid",
      "id": 11,
      "text": "black?"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "if target.black?\n          if target.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            node = new_child(~dir, target.new_color(:RED))\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            node = balanced_rotate(dir)\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          node = rotate(dir)\n          # try to rebalance in sub-tree\n          target, rebalance = node.child(dir).rebalance_for_delete(dir)\n          raise 'should not happen' if rebalance\n          node = node.new_children(dir, target, node.child(~dir))\n        end"
    },
    {
      "element type": "If statement",
      "id": 13
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 14,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 15,
      "text": "target.black?"
    },
    {
      "element type": "Compound statement",
      "id": 16,
      "text": "if target.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            node = new_child(~dir, target.new_color(:RED))\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            node = balanced_rotate(dir)\n          end"
    },
    {
      "element type": "If statement",
      "id": 17
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 18,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 19,
      "text": "target.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 20,
      "text": "target.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 21,
      "text": "node = new_child(~dir, target.new_color(:RED))\n            rebalance = true"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 22,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 23,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 24,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 25,
      "text": "target.new_color"
    },
    {
      "element type": "Call",
      "callee": "new_color",
      "id": 26,
      "text": "target.new_color(:RED)"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_child",
      "id": 27,
      "text": "new_child(~dir, target.new_color(:RED))"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 28,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 29,
      "operation type": "="
    },
    {
      "element type": "Pseudo constant",
      "id": 30,
      "text": "true"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 31,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 32,
      "operation type": "="
    },
    {
      "element type": "Else block",
      "id": 33
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 34,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "balanced_rotate",
      "id": 35,
      "text": "balanced_rotate(dir)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 36,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 37,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 38,
      "text": "node = balanced_rotate(dir)"
    },
    {
      "element type": "Else block",
      "id": 39
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 40,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "rotate",
      "id": 41,
      "text": "rotate(dir)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 42,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 43,
      "operation type": "="
    },
    {
      "element type": "Assignment expression",
      "id": 44,
      "operation type": "="
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 45,
      "text": "target"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 46,
      "text": "rebalance"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 47,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 48,
      "text": "node.child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 49,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 50,
      "text": "node.child(dir)"
    },
    {
      "element type": "Reference",
      "id": 51,
      "text": "node.child(dir).rebalance_for_delete"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 52,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "rebalance_for_delete",
      "id": 53,
      "text": "node.child(dir).rebalance_for_delete(dir)"
    },
    {
      "element type": "If mod statement",
      "id": 54
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 55,
      "text": "rebalance"
    },
    {
      "element type": "Call",
      "id": 56,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "String literal",
      "id": 57,
      "text": "'should not happen'",
      "value": "should not happen"
    },
    {
      "element type": "Call",
      "id": 58,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 59,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 60,
      "text": "node.new_children"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 61,
      "text": "dir"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 62,
      "text": "target"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 63,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 64,
      "text": "node.child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 65,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 66,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 67,
      "text": "node.child(~dir)"
    },
    {
      "element type": "Call",
      "callee": "new_children",
      "id": 68,
      "text": "node.new_children(dir, target, node.child(~dir))"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 69,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 70,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 71,
      "text": "node = rotate(dir)\n          # try to rebalance in sub-tree\n          target, rebalance = node.child(dir).rebalance_for_delete(dir)\n          raise 'should not happen' if rebalance\n          node = node.new_children(dir, target, node.child(~dir))"
    },
    {
      "element type": "Else block",
      "id": 72
    },
    {
      "element type": "If statement",
      "id": 73
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 74,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 75,
      "text": "target.children_color?"
    },
    {
      "element type": "Call",
      "call type": "TrueClass or FalseClass",
      "callee": "children_color?",
      "id": 76,
      "text": "target.children_color?(:BLACK)"
    },
    {
      "element type": "Compound statement",
      "id": 77,
      "text": "node = new_child(~dir, target.new_color(@color), target.color)"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 78,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 79,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 80,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 81,
      "text": "target.new_color"
    },
    {
      "element type": "Instance variable",
      "id": 82,
      "text": "@color"
    },
    {
      "element type": "Call",
      "callee": "new_color",
      "id": 83,
      "text": "target.new_color(@color)"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 84,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 85,
      "text": "target.color"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_child",
      "id": 86,
      "text": "new_child(~dir, target.new_color(@color), target.color)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 87,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 88,
      "operation type": "="
    },
    {
      "element type": "Else block",
      "id": 89
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 90,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "balanced_rotate",
      "id": 91,
      "text": "balanced_rotate(dir)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 92,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 93,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 94,
      "text": "node = balanced_rotate(dir)"
    },
    {
      "element type": "Compound statement",
      "id": 95,
      "text": "if target.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          node = new_child(~dir, target.new_color(@color), target.color)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          node = balanced_rotate(dir)\n        end"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 96,
      "text": "node"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 97,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 98,
      "text": "[node, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 99,
      "text": "target = child(~dir)\n      rebalance = false\n      if black?\n        if target.black?\n          if target.children_color?(:BLACK)\n            # make whole sub-tree 1 level lower and ask rebalance\n            node = new_child(~dir, target.new_color(:RED))\n            rebalance = true\n          else\n            # move 1 black from the right to the left by single/double rotation\n            node = balanced_rotate(dir)\n          end\n        else\n          # flip this sub-tree into another type of 3-children node\n          node = rotate(dir)\n          # try to rebalance in sub-tree\n          target, rebalance = node.child(dir).rebalance_for_delete(dir)\n          raise 'should not happen' if rebalance\n          node = node.new_children(dir, target, node.child(~dir))\n        end\n      else # red\n        if target.children_color?(:BLACK)\n          # make right sub-tree 1 level lower\n          node = new_child(~dir, target.new_color(@color), target.color)\n        else\n          # move 1 black from the right to the left by single/double rotation\n          node = balanced_rotate(dir)\n        end\n      end\n      [node, rebalance]"
    },
    {
      "element type": "Body statement",
      "id": 100
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [
        12,
        72
      ]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [
        16,
        39
      ]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [
        21,
        33
      ]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [96]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [96]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [43]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": [48]
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [53]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [55]
    },
    {
      "from": 55,
      "to": [
        56,
        59
      ]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": []
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [65]
    },
    {
      "from": 65,
      "to": [66]
    },
    {
      "from": 66,
      "to": [67]
    },
    {
      "from": 67,
      "to": [68]
    },
    {
      "from": 68,
      "to": [69]
    },
    {
      "from": 69,
      "to": [70]
    },
    {
      "from": 70,
      "to": [71]
    },
    {
      "from": 71,
      "to": [96]
    },
    {
      "from": 72,
      "to": [73]
    },
    {
      "from": 73,
      "to": [74]
    },
    {
      "from": 74,
      "to": [75]
    },
    {
      "from": 75,
      "to": [76]
    },
    {
      "from": 76,
      "to": [
        77,
        89
      ]
    },
    {
      "from": 77,
      "to": [78]
    },
    {
      "from": 78,
      "to": [79]
    },
    {
      "from": 79,
      "to": [80]
    },
    {
      "from": 80,
      "to": [81]
    },
    {
      "from": 81,
      "to": [82]
    },
    {
      "from": 82,
      "to": [83]
    },
    {
      "from": 83,
      "to": [84]
    },
    {
      "from": 84,
      "to": [85]
    },
    {
      "from": 85,
      "to": [86]
    },
    {
      "from": 86,
      "to": [87]
    },
    {
      "from": 87,
      "to": [88]
    },
    {
      "from": 88,
      "to": [95]
    },
    {
      "from": 89,
      "to": [90]
    },
    {
      "from": 90,
      "to": [91]
    },
    {
      "from": 91,
      "to": [92]
    },
    {
      "from": 92,
      "to": [93]
    },
    {
      "from": 93,
      "to": [94]
    },
    {
      "from": 94,
      "to": [95]
    },
    {
      "from": 95,
      "to": [96]
    },
    {
      "from": 96,
      "to": [97]
    },
    {
      "from": 97,
      "to": [98]
    },
    {
      "from": 98,
      "to": [99]
    },
    {
      "from": 99,
      "to": [100]
    },
    {
      "from": 100,
      "to": [101]
    },
    {
      "from": 101,
      "to": []
    }
  ],
  "holder": "rebalance_for_delete"
}



{
  "nodes description": [
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "dir"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 2,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 3,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 4,
      "text": "child(~dir)"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 5,
      "text": "target"
    },
    {
      "element type": "Assignment expression",
      "id": 6,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 7
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 8,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 9,
      "text": "target.child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 10,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 11,
      "text": "target.child(dir)"
    },
    {
      "element type": "Reference",
      "id": 12,
      "text": "target.child(dir).red?"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 15,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 16,
      "text": "target.child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 17,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 18,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 19,
      "text": "target.child(~dir)"
    },
    {
      "element type": "Reference",
      "id": 20,
      "text": "target.child(~dir).black?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 21,
      "text": "target.child(dir).red? and target.child(~dir).black?"
    },
    {
      "element type": "Compound statement",
      "id": 22,
      "text": "node = new_child(~dir, target.rotate(~dir))"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 23,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 24,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Identifier target",
      "reference": "target",
      "kind": "local variable",
      "id": 25,
      "text": "target"
    },
    {
      "element type": "Reference",
      "id": 26,
      "text": "target.rotate"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 27,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 28,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "rotate",
      "id": 29,
      "text": "target.rotate(~dir)"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_child",
      "id": 30,
      "text": "new_child(~dir, target.rotate(~dir))"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 31,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 32,
      "operation type": "="
    },
    {
      "element type": "Else block",
      "id": 33
    },
    {
      "element type": "Pseudo constant",
      "id": 34,
      "text": "self"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 35,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 36,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 37,
      "text": "node = self"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 38,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 39,
      "text": "node.rotate"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 40,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "rotate",
      "id": 41,
      "text": "node.rotate(dir)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 42,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 43,
      "operation type": "="
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 44,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 45,
      "text": "node.new_children"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 46,
      "text": "dir"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 47,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 48,
      "text": "node.child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 49,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 50,
      "text": "node.child(dir)"
    },
    {
      "element type": "Reference",
      "id": 51,
      "text": "node.child(dir).new_color"
    },
    {
      "element type": "Call",
      "callee": "new_color",
      "id": 52,
      "text": "node.child(dir).new_color(:BLACK)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 53,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 54,
      "text": "node.child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 55,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 56,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 57,
      "text": "node.child(~dir)"
    },
    {
      "element type": "Reference",
      "id": 58,
      "text": "node.child(~dir).new_color"
    },
    {
      "element type": "Call",
      "callee": "new_color",
      "id": 59,
      "text": "node.child(~dir).new_color(:BLACK)"
    },
    {
      "element type": "Call",
      "callee": "new_children",
      "id": 60,
      "text": "node.new_children(dir, node.child(dir).new_color(:BLACK), node.child(~dir).new_color(:BLACK))"
    },
    {
      "element type": "Compound statement",
      "id": 61,
      "text": "target = child(~dir)\n      if target.child(dir).red? and target.child(~dir).black?\n        node = new_child(~dir, target.rotate(~dir))\n      else\n        node = self\n      end\n      node = node.rotate(dir)\n      node.new_children(dir, node.child(dir).new_color(:BLACK), node.child(~dir).new_color(:BLACK))"
    },
    {
      "element type": "Body statement",
      "id": 62
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [
        13,
        14
      ]
    },
    {
      "from": 13,
      "to": [15]
    },
    {
      "from": 14,
      "to": [33]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [
        22,
        33
      ]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [38]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [41]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [43]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [45]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": [48]
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [53]
    },
    {
      "from": 53,
      "to": [54]
    },
    {
      "from": 54,
      "to": [55]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [57]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": []
    }
  ],
  "holder": "balanced_rotate"
}



{
  "nodes description": [
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "dir"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 2,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 3,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 4,
      "text": "child(~dir)"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 5,
      "text": "new_root"
    },
    {
      "element type": "Assignment expression",
      "id": 6,
      "operation type": "="
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 7,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 8,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 9,
      "text": "new_root"
    },
    {
      "element type": "Reference",
      "id": 10,
      "text": "new_root.child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 11,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 12,
      "text": "new_root.child(dir)"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 13,
      "text": "new_root"
    },
    {
      "element type": "Reference",
      "id": 14,
      "text": "new_root.color"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_child",
      "id": 15,
      "text": "new_child(~dir, new_root.child(dir), new_root.color)"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 16,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 17,
      "operation type": "="
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 18,
      "text": "new_root"
    },
    {
      "element type": "Reference",
      "id": 19,
      "text": "new_root.new_children"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 20,
      "text": "dir"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 21,
      "text": "node"
    },
    {
      "element type": "Identifier new_root",
      "reference": "new_root",
      "kind": "local variable",
      "id": 22,
      "text": "new_root"
    },
    {
      "element type": "Reference",
      "id": 23,
      "text": "new_root.child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 24,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 25,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 26,
      "text": "new_root.child(~dir)"
    },
    {
      "element type": "Instance variable",
      "id": 27,
      "text": "@color"
    },
    {
      "element type": "Call",
      "callee": "new_children",
      "id": 28,
      "text": "new_root.new_children(dir, node, new_root.child(~dir), @color)"
    },
    {
      "element type": "Compound statement",
      "id": 29,
      "text": "new_root = child(~dir)\n      node = new_child(~dir, new_root.child(dir), new_root.color)\n      new_root.new_children(dir, node, new_root.child(~dir), @color)"
    },
    {
      "element type": "Body statement",
      "id": 30
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": []
    }
  ],
  "holder": "rotate"
}



{
  "nodes description": [
    {
      "element type": "If statement",
      "id": 1
    },
    {
      "element type": "Fid",
      "id": 2,
      "text": "black?"
    },
    {
      "element type": "Instance variable",
      "id": 5,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 6,
      "text": "@left.red?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 7,
      "text": "black? and @left.red?"
    },
    {
      "element type": "Instance variable",
      "id": 10,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 11,
      "text": "@right.red?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 12,
      "text": "black? and @left.red? and @right.red?"
    },
    {
      "element type": "Compound statement",
      "id": 13,
      "text": "new_children(LEFT, @left.new_color(:BLACK), @right.new_color(:BLACK), :RED)"
    },
    {
      "element type": "Constant",
      "id": 14,
      "text": "LEFT"
    },
    {
      "element type": "Instance variable",
      "id": 15,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 16,
      "text": "@left.new_color"
    },
    {
      "element type": "Call",
      "callee": "new_color",
      "id": 17,
      "text": "@left.new_color(:BLACK)"
    },
    {
      "element type": "Instance variable",
      "id": 18,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 19,
      "text": "@right.new_color"
    },
    {
      "element type": "Call",
      "callee": "new_color",
      "id": 20,
      "text": "@right.new_color(:BLACK)"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_children",
      "id": 21,
      "text": "new_children(LEFT, @left.new_color(:BLACK), @right.new_color(:BLACK), :RED)"
    },
    {
      "element type": "Else block",
      "id": 22
    },
    {
      "element type": "Pseudo constant",
      "id": 23,
      "text": "self"
    },
    {
      "element type": "Compound statement",
      "id": 24,
      "text": "self"
    },
    {
      "element type": "Compound statement",
      "id": 25,
      "text": "if black? and @left.red? and @right.red?\n        new_children(LEFT, @left.new_color(:BLACK), @right.new_color(:BLACK), :RED)\n      else\n        self\n      end"
    },
    {
      "element type": "Body statement",
      "id": 26
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [
        3,
        4
      ]
    },
    {
      "from": 3,
      "to": [5]
    },
    {
      "from": 4,
      "to": [22]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [
        8,
        9
      ]
    },
    {
      "from": 8,
      "to": [10]
    },
    {
      "from": 9,
      "to": [22]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [
        13,
        22
      ]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [25]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": []
    }
  ],
  "holder": "pullup_red"
}



{
  "nodes description": [
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "dir"
    },
    {
      "element type": "Pseudo constant",
      "id": 2,
      "text": "self"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 3,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 4,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 5
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 6,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 7,
      "text": "child(dir)"
    },
    {
      "element type": "Reference",
      "id": 8,
      "text": "child(dir).child"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 9,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 10,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 11,
      "text": "child(dir).child(~dir)"
    },
    {
      "element type": "Reference",
      "id": 12,
      "text": "child(dir).child(~dir).red?"
    },
    {
      "element type": "Compound statement",
      "id": 13,
      "text": "node = new_child(dir, child(dir).rotate(dir))"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 14,
      "text": "dir"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 15,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "child",
      "id": 16,
      "text": "child(dir)"
    },
    {
      "element type": "Reference",
      "id": 17,
      "text": "child(dir).rotate"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 18,
      "text": "dir"
    },
    {
      "element type": "Call",
      "callee": "rotate",
      "id": 19,
      "text": "child(dir).rotate(dir)"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "callee": "new_child",
      "id": 20,
      "text": "new_child(dir, child(dir).rotate(dir))"
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 21,
      "text": "node"
    },
    {
      "element type": "Assignment expression",
      "id": 22,
      "operation type": "="
    },
    {
      "element type": "Identifier node",
      "reference": "node",
      "kind": "local variable",
      "id": 23,
      "text": "node"
    },
    {
      "element type": "Reference",
      "id": 24,
      "text": "node.rotate"
    },
    {
      "element type": "Identifier dir",
      "reference": "dir",
      "kind": "local variable",
      "id": 25,
      "text": "dir"
    },
    {
      "element type": "Unary expression",
      "id": 26,
      "text": "~dir",
      "operation": "~"
    },
    {
      "element type": "Call",
      "callee": "rotate",
      "id": 27,
      "text": "node.rotate(~dir)"
    },
    {
      "element type": "Compound statement",
      "id": 28,
      "text": "node = self\n      if child(dir).child(~dir).red?\n        node = new_child(dir, child(dir).rotate(dir))\n      end\n      node.rotate(~dir)"
    },
    {
      "element type": "Body statement",
      "id": 29
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [
        13,
        23
      ]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": []
    }
  ],
  "holder": "rebalance_for_insert"
}



{
  "nodes description": [
    {
      "element type": "Pseudo constant",
      "id": 1,
      "text": "false"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 2,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 3,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 4
    },
    {
      "element type": "Instance variable",
      "id": 5,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 6,
      "text": "@left.empty?"
    },
    {
      "element type": "Instance variable",
      "id": 9,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 10,
      "text": "@right.empty?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 11,
      "text": "@left.empty? and @right.empty?"
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "new_node = EMPTY_CONCURRENT\n        if black?\n          rebalance = true\n        end"
    },
    {
      "element type": "Constant",
      "id": 13,
      "text": "EMPTY_CONCURRENT"
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 14,
      "text": "new_node"
    },
    {
      "element type": "Assignment expression",
      "id": 15,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 16
    },
    {
      "element type": "Fid",
      "id": 17,
      "text": "black?"
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "rebalance = true"
    },
    {
      "element type": "Pseudo constant",
      "id": 19,
      "text": "true"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 20,
      "text": "rebalance"
    },
    {
      "element type": "Assignment expression",
      "id": 21,
      "operation type": "="
    },
    {
      "element type": "Instance variable",
      "id": 22,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 23,
      "text": "@left.empty?"
    },
    {
      "element type": "Instance variable",
      "id": 26,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 27,
      "text": "@right.empty?"
    },
    {
      "element type": "Boolean binary expression",
      "id": 28,
      "text": "@left.empty? or @right.empty?"
    },
    {
      "element type": "Compound statement",
      "id": 29,
      "text": "new_node = EMPTY_CONCURRENT\n        if black?\n          rebalance = true\n        end"
    },
    {
      "element type": "Ternary expression",
      "id": 30
    },
    {
      "element type": "Instance variable",
      "id": 31,
      "text": "@left"
    },
    {
      "element type": "Reference",
      "id": 32,
      "text": "@left.empty?"
    },
    {
      "element type": "Instance variable",
      "id": 33,
      "text": "@right"
    },
    {
      "element type": "Instance variable",
      "id": 34,
      "text": "@right"
    },
    {
      "element type": "Instance variable",
      "id": 35,
      "text": "@left"
    },
    {
      "element type": "Instance variable",
      "id": 36,
      "text": "@left"
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 37,
      "text": "new_node"
    },
    {
      "element type": "Assignment expression",
      "id": 38,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 39
    },
    {
      "element type": "Fid",
      "id": 40,
      "text": "black?"
    },
    {
      "element type": "Compound statement",
      "id": 41,
      "text": "raise 'should not happen' unless new_node.red?\n          new_node = new_node.new_color(@color)"
    },
    {
      "element type": "Unless mod statement",
      "id": 42
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 43,
      "text": "new_node"
    },
    {
      "element type": "Reference",
      "id": 44,
      "text": "new_node.red?"
    },
    {
      "element type": "Call",
      "id": 45,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "String literal",
      "id": 46,
      "text": "'should not happen'",
      "value": "should not happen"
    },
    {
      "element type": "Call",
      "id": 47,
      "text": "raise 'should not happen'"
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 48,
      "text": "new_node"
    },
    {
      "element type": "Reference",
      "id": 49,
      "text": "new_node.new_color"
    },
    {
      "element type": "Instance variable",
      "id": 50,
      "text": "@color"
    },
    {
      "element type": "Call",
      "callee": "new_color",
      "id": 51,
      "text": "new_node.new_color(@color)"
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 52,
      "text": "new_node"
    },
    {
      "element type": "Assignment expression",
      "id": 53,
      "operation type": "="
    },
    {
      "element type": "Else block",
      "id": 54
    },
    {
      "element type": "Compound statement",
      "id": 55,
      "text": ""
    },
    {
      "element type": "Compound statement",
      "id": 56,
      "text": "new_node = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_node.red?\n          new_node = new_node.new_color(@color)\n        else\n          # just remove the red node\n        end"
    },
    {
      "element type": "Else block",
      "id": 57
    },
    {
      "element type": "Assignment expression",
      "id": 58,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 59,
      "text": "deleted"
    },
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "local variable",
      "id": 60,
      "text": "right"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 61,
      "text": "rebalance"
    },
    {
      "element type": "Instance variable",
      "id": 62,
      "text": "@right"
    },
    {
      "element type": "Reference",
      "id": 63,
      "text": "@right.delete_min"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 64,
      "text": "deleted"
    },
    {
      "element type": "Reference",
      "id": 65,
      "text": "deleted.new_children"
    },
    {
      "element type": "Constant",
      "id": 66,
      "text": "LEFT"
    },
    {
      "element type": "Instance variable",
      "id": 67,
      "text": "@left"
    },
    {
      "element type": "Identifier right",
      "reference": "right",
      "kind": "local variable",
      "id": 68,
      "text": "right"
    },
    {
      "element type": "Instance variable",
      "id": 69,
      "text": "@color"
    },
    {
      "element type": "Call",
      "callee": "new_children",
      "id": 70,
      "text": "deleted.new_children(LEFT, @left, right, @color)"
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 71,
      "text": "new_node"
    },
    {
      "element type": "Assignment expression",
      "id": 72,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 73
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 74,
      "text": "rebalance"
    },
    {
      "element type": "Compound statement",
      "id": 75,
      "text": "new_node, rebalance = new_node.rebalance_for_delete(RIGHT)"
    },
    {
      "element type": "Assignment expression",
      "id": 76,
      "operation type": "="
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 77,
      "text": "new_node"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 78,
      "text": "rebalance"
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 79,
      "text": "new_node"
    },
    {
      "element type": "Reference",
      "id": 80,
      "text": "new_node.rebalance_for_delete"
    },
    {
      "element type": "Constant",
      "id": 81,
      "text": "RIGHT"
    },
    {
      "element type": "Call",
      "call type": "Duck type [rebalance_for_delete]",
      "callee": "rebalance_for_delete",
      "id": 82,
      "text": "new_node.rebalance_for_delete(RIGHT)"
    },
    {
      "element type": "Compound statement",
      "id": 83,
      "text": "deleted, right, rebalance = @right.delete_min\n        new_node = deleted.new_children(LEFT, @left, right, @color)\n        if rebalance\n          new_node, rebalance = new_node.rebalance_for_delete(RIGHT)\n        end"
    },
    {
      "element type": "Identifier new_node",
      "reference": "new_node",
      "kind": "local variable",
      "id": 84,
      "text": "new_node"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 85,
      "text": "rebalance"
    },
    {
      "element type": "Array",
      "id": 86,
      "text": "[new_node, rebalance]"
    },
    {
      "element type": "Compound statement",
      "id": 87,
      "text": "rebalance = false\n      if @left.empty? and @right.empty?\n        # just remove this node and ask rebalance to the parent\n        new_node = EMPTY_CONCURRENT\n        if black?\n          rebalance = true\n        end\n      elsif @left.empty? or @right.empty?\n        # pick the single children\n        new_node = @left.empty? ? @right : @left\n        if black?\n          # keep the color black\n          raise 'should not happen' unless new_node.red?\n          new_node = new_node.new_color(@color)\n        else\n          # just remove the red node\n        end\n      else\n        # pick the minimum node from the right sub-tree and replace self with it\n        deleted, right, rebalance = @right.delete_min\n        new_node = deleted.new_children(LEFT, @left, right, @color)\n        if rebalance\n          new_node, rebalance = new_node.rebalance_for_delete(RIGHT)\n        end\n      end\n      [new_node, rebalance]"
    },
    {
      "element type": "Body statement",
      "id": 88
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [
        7,
        8
      ]
    },
    {
      "from": 7,
      "to": [9]
    },
    {
      "from": 8,
      "to": [22]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [
        12,
        22
      ]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [
        18,
        84
      ]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [84]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [
        24,
        25
      ]
    },
    {
      "from": 24,
      "to": [29]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [
        29,
        57
      ]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [32]
    },
    {
      "from": 32,
      "to": [
        33,
        35
      ]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [37]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": [38]
    },
    {
      "from": 38,
      "to": [39]
    },
    {
      "from": 39,
      "to": [40]
    },
    {
      "from": 40,
      "to": [
        41,
        54
      ]
    },
    {
      "from": 41,
      "to": [42]
    },
    {
      "from": 42,
      "to": [43]
    },
    {
      "from": 43,
      "to": [44]
    },
    {
      "from": 44,
      "to": [
        45,
        48
      ]
    },
    {
      "from": 45,
      "to": [46]
    },
    {
      "from": 46,
      "to": [47]
    },
    {
      "from": 47,
      "to": []
    },
    {
      "from": 48,
      "to": [49]
    },
    {
      "from": 49,
      "to": [50]
    },
    {
      "from": 50,
      "to": [51]
    },
    {
      "from": 51,
      "to": [52]
    },
    {
      "from": 52,
      "to": [53]
    },
    {
      "from": 53,
      "to": [56]
    },
    {
      "from": 54,
      "to": [55]
    },
    {
      "from": 55,
      "to": [56]
    },
    {
      "from": 56,
      "to": [84]
    },
    {
      "from": 57,
      "to": [58]
    },
    {
      "from": 58,
      "to": [59]
    },
    {
      "from": 59,
      "to": [60]
    },
    {
      "from": 60,
      "to": [61]
    },
    {
      "from": 61,
      "to": [62]
    },
    {
      "from": 62,
      "to": [63]
    },
    {
      "from": 63,
      "to": [64]
    },
    {
      "from": 64,
      "to": [65]
    },
    {
      "from": 65,
      "to": [66]
    },
    {
      "from": 66,
      "to": [67]
    },
    {
      "from": 67,
      "to": [68]
    },
    {
      "from": 68,
      "to": [69]
    },
    {
      "from": 69,
      "to": [70]
    },
    {
      "from": 70,
      "to": [71]
    },
    {
      "from": 71,
      "to": [72]
    },
    {
      "from": 72,
      "to": [73]
    },
    {
      "from": 73,
      "to": [74]
    },
    {
      "from": 74,
      "to": [
        75,
        83
      ]
    },
    {
      "from": 75,
      "to": [76]
    },
    {
      "from": 76,
      "to": [77]
    },
    {
      "from": 77,
      "to": [78]
    },
    {
      "from": 78,
      "to": [79]
    },
    {
      "from": 79,
      "to": [80]
    },
    {
      "from": 80,
      "to": [81]
    },
    {
      "from": 81,
      "to": [82]
    },
    {
      "from": 82,
      "to": [83]
    },
    {
      "from": 83,
      "to": [84]
    },
    {
      "from": 84,
      "to": [85]
    },
    {
      "from": 85,
      "to": [86]
    },
    {
      "from": 86,
      "to": [87]
    },
    {
      "from": 87,
      "to": [88]
    },
    {
      "from": 88,
      "to": [89]
    },
    {
      "from": 89,
      "to": []
    }
  ],
  "holder": "delete_node"
}



{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "EmptyConcurrentNode"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "EmptyNode"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "def insert(key, value)\n        ConcurrentNode.new(key, value, self, self)\n      end"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "EmptyConcurrentNode"
}


{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "value"
    },
    {
      "element type": "Constant",
      "id": 3,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "ConcurrentNode.new"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 5,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 6,
      "text": "value"
    },
    {
      "element type": "Pseudo constant",
      "id": 7,
      "text": "self"
    },
    {
      "element type": "Pseudo constant",
      "id": 8,
      "text": "self"
    },
    {
      "element type": "Call",
      "call type": "ConcurrentRedBlackTree::ConcurrentNode",
      "id": 9,
      "text": "ConcurrentNode.new(key, value, self, self)"
    },
    {
      "element type": "Compound statement",
      "id": 10,
      "text": "ConcurrentNode.new(key, value, self, self)"
    },
    {
      "element type": "Body statement",
      "id": 11
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": []
    }
  ],
  "holder": "insert"
}



{
  "nodes description": [
    {
      "element type": "Constant",
      "id": 1,
      "text": "DEFAULT"
    },
    {
      "element type": "Identifier default",
      "reference": "default",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "default"
    },
    {
      "element type": "Identifier block",
      "reference": "block",
      "kind": "method parameter declaration",
      "id": 3,
      "text": "block"
    },
    {
      "element type": "Pseudo constant",
      "id": 4,
      "text": "super"
    },
    {
      "element type": "Constant",
      "id": 5,
      "text": "Atomic"
    },
    {
      "element type": "Reference",
      "id": 6,
      "text": "Atomic.new"
    },
    {
      "element type": "Constant",
      "id": 7,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Colon reference",
      "id": 8,
      "text": "ConcurrentNode::EMPTY_CONCURRENT"
    },
    {
      "element type": "Call",
      "id": 9,
      "text": "Atomic.new(ConcurrentNode::EMPTY_CONCURRENT)"
    },
    {
      "element type": "Instance variable",
      "id": 10,
      "text": "@root"
    },
    {
      "element type": "Assignment expression",
      "id": 11,
      "operation type": "="
    },
    {
      "element type": "Compound statement",
      "id": 12,
      "text": "super\n    @root = Atomic.new(ConcurrentNode::EMPTY_CONCURRENT)"
    },
    {
      "element type": "Body statement",
      "id": 13
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": []
    }
  ],
  "holder": "initialize"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 2,
      "text": "@root.get"
    },
    {
      "element type": "Compound statement",
      "id": 3,
      "text": "@root.get"
    },
    {
      "element type": "Body statement",
      "id": 4
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": []
    }
  ],
  "holder": "root"
}



{
  "nodes description": [
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "unknown",
      "id": 1,
      "text": "root"
    },
    {
      "element type": "Constant",
      "id": 2,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Colon reference",
      "id": 3,
      "text": "ConcurrentNode::EMPTY_CONCURRENT"
    },
    {
      "element type": "Binary expression",
      "id": 4,
      "text": "root == ConcurrentNode::EMPTY_CONCURRENT",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Compound statement",
      "id": 5,
      "text": "root == ConcurrentNode::EMPTY_CONCURRENT"
    },
    {
      "element type": "Body statement",
      "id": 6
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": []
    }
  ],
  "holder": "empty?"
}



{
  "nodes description": [
    {
      "element type": "Instance variable",
      "id": 1,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 2,
      "text": "@root.set"
    },
    {
      "element type": "Constant",
      "id": 3,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Colon reference",
      "id": 4,
      "text": "ConcurrentNode::EMPTY_CONCURRENT"
    },
    {
      "element type": "Call",
      "id": 5,
      "text": "@root.set(ConcurrentNode::EMPTY_CONCURRENT)"
    },
    {
      "element type": "Compound statement",
      "id": 6,
      "text": "@root.set(ConcurrentNode::EMPTY_CONCURRENT)"
    },
    {
      "element type": "Body statement",
      "id": 7
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": []
    }
  ],
  "holder": "clear"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "method parameter declaration",
      "id": 2,
      "text": "value"
    },
    {
      "element type": "Instance variable",
      "id": 3,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "@root.update"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "block parameter declaration",
      "id": 5,
      "text": "root"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 6,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 7,
      "text": "root.insert"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 8,
      "text": "key"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 9,
      "text": "value"
    },
    {
      "element type": "Call",
      "id": 10,
      "text": "root.insert(key, value)"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 11,
      "text": "root"
    },
    {
      "element type": "Assignment expression",
      "id": 12,
      "operation type": "="
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 13,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 14,
      "text": "root.set_root"
    },
    {
      "element type": "If mod statement",
      "id": 15
    },
    {
      "element type": "Global variable",
      "id": 16,
      "text": "$DEBUG",
      "variable type": "GLOBAL_VARIABLE"
    },
    {
      "element type": "Reference",
      "id": 17,
      "text": "root.check_height"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 18,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 19,
      "text": "root.check_height"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 20,
      "text": "root"
    },
    {
      "element type": "Compound statement",
      "id": 21,
      "text": "root = root.insert(key, value)\n      root.set_root\n      root.check_height if $DEBUG\n      root"
    },
    {
      "element type": "Code block",
      "id": 22
    },
    {
      "element type": "Block call",
      "id": 23
    },
    {
      "element type": "Compound statement",
      "id": 24,
      "text": "@root.update { |root|\n      root = root.insert(key, value)\n      root.set_root\n      root.check_height if $DEBUG\n      root\n    }"
    },
    {
      "element type": "Body statement",
      "id": 25
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [
        5,
        23
      ]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [
        17,
        20
      ]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [
        23,
        5
      ]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [26]
    },
    {
      "from": 26,
      "to": []
    }
  ],
  "holder": "[]="
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Instance variable",
      "id": 2,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 3,
      "text": "@root.get"
    },
    {
      "element type": "Reference",
      "id": 4,
      "text": "@root.get.retrieve"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 5,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 6,
      "text": "@root.get.retrieve(key)"
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 7,
      "text": "value"
    },
    {
      "element type": "Assignment expression",
      "id": 8,
      "operation type": "="
    },
    {
      "element type": "If statement",
      "id": 9
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 10,
      "text": "value"
    },
    {
      "element type": "Constant",
      "id": 11,
      "text": "Node"
    },
    {
      "element type": "Colon reference",
      "id": 12,
      "text": "Node::UNDEFINED"
    },
    {
      "element type": "Binary expression",
      "id": 13,
      "text": "value == Node::UNDEFINED",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Compound statement",
      "id": 14,
      "text": "default_value"
    },
    {
      "element type": "Identifier default_value",
      "reference": "default_value",
      "kind": "unknown",
      "id": 15,
      "text": "default_value"
    },
    {
      "element type": "Else block",
      "id": 16
    },
    {
      "element type": "Identifier value",
      "reference": "value",
      "kind": "local variable",
      "id": 17,
      "text": "value"
    },
    {
      "element type": "Compound statement",
      "id": 18,
      "text": "value"
    },
    {
      "element type": "Compound statement",
      "id": 19,
      "text": "value = @root.get.retrieve(key)\n    if value == Node::UNDEFINED\n      default_value\n    else\n      value\n    end"
    },
    {
      "element type": "Body statement",
      "id": 20
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [7]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [
        14,
        16
      ]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [19]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [21]
    },
    {
      "from": 21,
      "to": []
    }
  ],
  "holder": "[]"
}



{
  "nodes description": [
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "method parameter declaration",
      "id": 1,
      "text": "key"
    },
    {
      "element type": "Pseudo constant",
      "id": 2,
      "text": "nil"
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 3,
      "text": "deleted"
    },
    {
      "element type": "Assignment expression",
      "id": 4,
      "operation type": "="
    },
    {
      "element type": "Instance variable",
      "id": 5,
      "text": "@root"
    },
    {
      "element type": "Reference",
      "id": 6,
      "text": "@root.update"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "block parameter declaration",
      "id": 7,
      "text": "root"
    },
    {
      "element type": "Assignment expression",
      "id": 8,
      "operation type": "="
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 9,
      "text": "deleted"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 10,
      "text": "root"
    },
    {
      "element type": "Identifier rebalance",
      "reference": "rebalance",
      "kind": "local variable",
      "id": 11,
      "text": "rebalance"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 12,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 13,
      "text": "root.delete"
    },
    {
      "element type": "Identifier key",
      "reference": "key",
      "kind": "local variable",
      "id": 14,
      "text": "key"
    },
    {
      "element type": "Call",
      "id": 15,
      "text": "root.delete(key)"
    },
    {
      "element type": "Unless statement",
      "id": 16
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 17,
      "text": "root"
    },
    {
      "element type": "Constant",
      "id": 18,
      "text": "ConcurrentNode"
    },
    {
      "element type": "Colon reference",
      "id": 19,
      "text": "ConcurrentNode::EMPTY_CONCURRENT"
    },
    {
      "element type": "Binary expression",
      "id": 20,
      "text": "root == ConcurrentNode::EMPTY_CONCURRENT",
      "expression type": "TrueClass or FalseClass",
      "operation type": "=="
    },
    {
      "element type": "Compound statement",
      "id": 21,
      "text": "root.set_root\n        root.check_height if $DEBUG"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 22,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 23,
      "text": "root.set_root"
    },
    {
      "element type": "If mod statement",
      "id": 24
    },
    {
      "element type": "Global variable",
      "id": 25,
      "text": "$DEBUG",
      "variable type": "GLOBAL_VARIABLE"
    },
    {
      "element type": "Reference",
      "id": 26,
      "text": "root.check_height"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 27,
      "text": "root"
    },
    {
      "element type": "Reference",
      "id": 28,
      "text": "root.check_height"
    },
    {
      "element type": "Identifier root",
      "reference": "root",
      "kind": "local variable",
      "id": 29,
      "text": "root"
    },
    {
      "element type": "Compound statement",
      "id": 30,
      "text": "deleted, root, rebalance = root.delete(key)\n      unless root == ConcurrentNode::EMPTY_CONCURRENT\n        root.set_root\n        root.check_height if $DEBUG\n      end\n      root"
    },
    {
      "element type": "Code block",
      "id": 31
    },
    {
      "element type": "Block call",
      "id": 32
    },
    {
      "element type": "Identifier deleted",
      "reference": "deleted",
      "kind": "local variable",
      "id": 33,
      "text": "deleted"
    },
    {
      "element type": "Reference",
      "id": 34,
      "text": "deleted.value"
    },
    {
      "element type": "Compound statement",
      "id": 35,
      "text": "deleted = nil\n    @root.update { |root|\n      deleted, root, rebalance = root.delete(key)\n      unless root == ConcurrentNode::EMPTY_CONCURRENT\n        root.set_root\n        root.check_height if $DEBUG\n      end\n      root\n    }\n    deleted.value"
    },
    {
      "element type": "Body statement",
      "id": 36
    }
  ],
  "adjacency": [
    {
      "from": 0,
      "to": [1]
    },
    {
      "from": 1,
      "to": [2]
    },
    {
      "from": 2,
      "to": [3]
    },
    {
      "from": 3,
      "to": [4]
    },
    {
      "from": 4,
      "to": [5]
    },
    {
      "from": 5,
      "to": [6]
    },
    {
      "from": 6,
      "to": [
        7,
        32
      ]
    },
    {
      "from": 7,
      "to": [8]
    },
    {
      "from": 8,
      "to": [9]
    },
    {
      "from": 9,
      "to": [10]
    },
    {
      "from": 10,
      "to": [11]
    },
    {
      "from": 11,
      "to": [12]
    },
    {
      "from": 12,
      "to": [13]
    },
    {
      "from": 13,
      "to": [14]
    },
    {
      "from": 14,
      "to": [15]
    },
    {
      "from": 15,
      "to": [16]
    },
    {
      "from": 16,
      "to": [17]
    },
    {
      "from": 17,
      "to": [18]
    },
    {
      "from": 18,
      "to": [19]
    },
    {
      "from": 19,
      "to": [20]
    },
    {
      "from": 20,
      "to": [
        21,
        29
      ]
    },
    {
      "from": 21,
      "to": [22]
    },
    {
      "from": 22,
      "to": [23]
    },
    {
      "from": 23,
      "to": [24]
    },
    {
      "from": 24,
      "to": [25]
    },
    {
      "from": 25,
      "to": [
        26,
        29
      ]
    },
    {
      "from": 26,
      "to": [27]
    },
    {
      "from": 27,
      "to": [28]
    },
    {
      "from": 28,
      "to": [29]
    },
    {
      "from": 29,
      "to": [30]
    },
    {
      "from": 30,
      "to": [31]
    },
    {
      "from": 31,
      "to": [
        32,
        7
      ]
    },
    {
      "from": 32,
      "to": [33]
    },
    {
      "from": 33,
      "to": [34]
    },
    {
      "from": 34,
      "to": [35]
    },
    {
      "from": 35,
      "to": [36]
    },
    {
      "from": 36,
      "to": [37]
    },
    {
      "from": 37,
      "to": []
    }
  ],
  "holder": "delete"
}


